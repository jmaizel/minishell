#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/includes/ft_printf.h"
# include "../libft/includes/libft.h"
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <limits.h>
# include <stdio.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stdlib.h>
# include <string.h>
# include <sys/wait.h>
# include <unistd.h>

typedef struct s_tools
{
	char			**env;
	// Variables d'environnement (tableau de chaînes de caractères)
	int				exit_code;
	// Code de sortie de la dernière commande exécutée
	struct s_simple_cmds *cmds; // Liste des commandes à exécuter
	struct s_tokens *tokens;    // Liste des tokens générés par le lexer
								// D'autres champs peuvent être ajoutés ici selon les besoins du projet
}					t_tools;

// CLEMENT : Structure principale qui contient une commande complète
typedef struct s_sep
{
	char *cmd_sep; // Commande complète brute
	struct s_sep	*prev;
	struct s_sep	*next;
	struct s_pip *pipcell; //  IMPORTANT: Point d'entrée de la liste des pipes
}					t_sep;

// CLEMENT : Structure pour les arguments de la commande (format execve)
typedef struct s_cmd_args
{
	char **argv; //  IMPORTANT: Tableau d'arguments pour execve
	int argc;    // Nombre d'arguments
	char *cmd;   // Nom de la commande
}					t_cmd_args;

// CLEMENT : Structure pour les redirections de chaque commande
typedef struct s_parsed_cmd
{
	char *full_cmd; // Commande complète avec redirections
	char *cmd;      //  Commande sans redirections

	//  IMPORTANT: Redirections d'entrée (<)
	char **input_file; // Tableau des fichiers d'entrée
	int input_count;   // Nombre de fichiers d'entrée

	//  IMPORTANT: Redirections de sortie (>)
	char **output_file; // Tableau des fichiers de sortie
	int output_count;   // Nombre de fichiers de sortie

	//  IMPORTANT: Redirections append (>>)
	char **append_file; // Tableau des fichiers append
	int append_count;   // Nombre de fichiers append

	//  IMPORTANT: Heredocs (<<)
	char **heredoc_delim; // Tableau des délimiteurs heredoc
	int heredoc_count;    // Nombre de heredocs
}					t_parsed_cmd;

// CLEMENT :  STRUCTURE PRINCIPALE POUR L'EXÉCUTION
// C'est ici que tu trouveras toutes les infos pour chaque commande du pipeline
typedef struct s_pip
{
	char *cmd_pipe;            // Commande brute pour ce pipe
	t_parsed_cmd *redirection; //  Toutes les redirections pour cette commande
	struct s_pip *next;        //  Commande suivante dans le pipeline
	struct s_pip *prev;        // Commande précédente
	int pip_count;             // Nombre total de pipes
}					t_pip;

// CLEMENT : Pour accéder aux informations :
// 1. Tu reçois un t_sep *cell
// 2. Tu accèdes à la liste des pipes avec cell->pipcell
// 3. Pour chaque pipe (t_pip):
//    - Tu as la commande dans cmd_pipe
//    - Tu as toutes les redirections dans redirection
//    - Tu passes au pipe suivant avec next
//
// Exemple de parcours :
// t_pip *current = cell->pipcell;
// while (current)
// {
//     // Traiter les redirections avec current->redirection
//     // Exécuter la commande
//     current = current->next;
// }

// env :
void				print_env_vars(t_tools *tools);
char				**get_env_paths(char **env, char *var_name);

// parsing :
t_parsed_cmd		*parse_redir(char *input);
void				parsing_line(char *user_input, t_tools *tools);
void				free_parsed_cmd(t_parsed_cmd *cmd);
void				print_parsed_command(t_parsed_cmd *cmd);
void				parse_pipes(t_sep *cell);
void				loop_prompt(t_tools *tools, char **env);
t_sep				*add_cell(t_sep *list, char *cmd_sep, int pos);
t_sep				*create_cell(char *cmd_sep);
void				setup_signals(void);
void				handle_signal(int sig);
char				*get_user_input(void);
void				free_str_array(char **array);
int					ft_isspace(int c);
int					check_invalid_chars(const char *cmd);
char				*clean_quotes(char *str);
void				free_cell(t_sep *cell);
int					count_args(char *str);
void				print_pipe_command(t_pip *pipe_cmd, int pipe_num);

t_cmd_args			*parse_command_args(char *cmd_str);
void				print_cmd_args(t_cmd_args *cm#ifndef MINISHELL_H
# define MINISHELL_H

# include "../libft/includes/ft_printf.h"
# include "../libft/includes/libft.h"
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <limits.h>
# include <stdio.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stdlib.h>
# include <string.h>
# include <sys/wait.h>
# include <unistd.h>

typedef struct s_tools
{
	char			**env;
	// Variables d'environnement (tableau de chaînes de caractères)
	int				exit_code;
	// Code de sortie de la dernière commande exécutée
	struct s_simple_cmds *cmds; // Liste des commandes à exécuter
	struct s_tokens *tokens;    // Liste des tokens générés par le lexer
								// D'autres champs peuvent être ajoutés ici selon les besoins du projet
}					t_tools;

// CLEMENT : Structure principale qui contient une commande complète
typedef struct s_sep
{
	char *cmd_sep; // Commande complète brute
	struct s_sep	*prev;
	struct s_sep	*next;
	struct s_pip *pipcell; //  IMPORTANT: Point d'entrée de la liste des pipes
}					t_sep;

// CLEMENT : Structure pour les arguments de la commande (format execve)
typedef struct s_cmd_args
{
	char **argv; //  IMPORTANT: Tableau d'arguments pour execve
	int argc;    // Nombre d'arguments
	char *cmd;   // Nom de la commande
}					t_cmd_args;

// CLEMENT : Structure pour les redirections de chaque commande
typedef struct s_parsed_cmd
{
	char *full_cmd; // Commande complète avec redirections
	char *cmd;      //  Commande sans redirections

	//  IMPORTANT: Redirections d'entrée (<)
	char **input_file; // Tableau des fichiers d'entrée
	int input_count;   // Nombre de fichiers d'entrée

	//  IMPORTANT: Redirections de sortie (>)
	char **output_file; // Tableau des fichiers de sortie
	int output_count;   // Nombre de fichiers de sortie

	//  IMPORTANT: Redirections append (>>)
	char **append_file; // Tableau des fichiers append
	int append_count;   // Nombre de fichiers append

	//  IMPORTANT: Heredocs (<<)
	char **heredoc_delim; // Tableau des délimiteurs heredoc
	int heredoc_count;    // Nombre de heredocs
}					t_parsed_cmd;

// CLEMENT :  STRUCTURE PRINCIPALE POUR L'EXÉCUTION
// C'est ici que tu trouveras toutes les infos pour chaque commande du pipeline
typedef struct s_pip
{
	char *cmd_pipe;            // Commande brute pour ce pipe
	t_parsed_cmd *redirection; //  Toutes les redirections pour cette commande
	struct s_pip *next;        //  Commande suivante dans le pipeline
	struct s_pip *prev;        // Commande précédente
	int pip_count;             // Nombre total de pipes
}					t_pip;

// CLEMENT : Pour accéder aux informations :
// 1. Tu reçois un t_sep *cell
// 2. Tu accèdes à la liste des pipes avec cell->pipcell
// 3. Pour chaque pipe (t_pip):
//    - Tu as la commande dans cmd_pipe
//    - Tu as toutes les redirections dans redirection
//    - Tu passes au pipe suivant avec next
//
// Exemple de parcours :
// t_pip *current = cell->pipcell;
// while (current)
// {
//     // Traiter les redirections avec current->redirection
//     // Exécuter la commande
//     current = current->next;
// }

// env :
void				print_env_vars(t_tools *tools);
char				**get_env_paths(char **env, char *var_name);

// parsing :
t_parsed_cmd		*parse_redir(char *input);
void				parsing_line(char *user_input, t_tools *tools);
void				free_parsed_cmd(t_parsed_cmd *cmd);
void				print_parsed_command(t_parsed_cmd *cmd);
void				parse_pipes(t_sep *cell);
void				loop_prompt(t_tools *tools, char **env);
t_sep				*add_cell(t_sep *list, char *cmd_sep, int pos);
t_sep				*create_cell(char *cmd_sep);
void				setup_signals(void);
void				handle_signal(int sig);
char				*get_user_input(void);
void				free_str_array(char **array);
int					ft_isspace(int c);
int					check_invalid_chars(const char *cmd);
char				*clean_quotes(char *str);
void				free_cell(t_sep *cell);
int					count_args(char *str);
void				print_pipe_command(t_pip *pipe_cmd, int pipe_num);

t_cmd_args			*parse_command_args(char *cmd_str);
void				print_cmd_args(t_cmd_args *cmd_args);
void				free_cmd_args(t_cmd_args *cmd_args);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:07:09 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/04 10:40:47 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	count_args(char *str)
{
	int		count;
	int		i;
	int		in_quotes;
	char	quote_type;
	int		in_word;

	count = 0;
	i = 0;
	in_quotes = 0;
	in_word = 0;
	while (str[i])
	{
		if (!in_quotes && (str[i] == '"' || str[i] == '\''))
		{
			quote_type = str[i];
			in_quotes = 1;
			if (!in_word)
			{
				count++;
				in_word = 1;
			}
		}
		else if (in_quotes && str[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && ft_isspace(str[i]))
			in_word = 0;
		else if (!in_word)
		{
			count++;
			in_word = 1;
		}
		i++;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:06:11 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/20 11:24:09 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_env_vars(t_tools *tools)
{
	char	**current_env;

	current_env = tools->env;
	while (*current_env)
	{
		ft_printf("%s\n", *current_env);
		current_env++;
	}
}

char	**get_env_paths(char **env, char *var_name)
{
	int		i;
	char	*value;
	char	**paths;

	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], var_name, ft_strlen(var_name)) == 0)
		{
			value = env[i] + ft_strlen(var_name) + 1;
			paths = ft_split(value, ':');
			return (paths);
		}
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_command_args.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 11:38:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:16:54 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

t_cmd_args	*parse_command_args(char *cmd_str)
{
	t_cmd_args	*cmd_args;
	int			i;
	int			j;
	int			start;
	int			in_quotes;
	char		quote_type;
	char		**args;

	if (!cmd_str)
		return (NULL);
	cmd_args = malloc(sizeof(t_cmd_args));
	if d_args);
void				free_cmd_args(t_cmd_args *cmd_args);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:07:09 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/04 10:40:47 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	count_args(char *str)
{
	int		count;
	int		i;
	int		in_quotes;
	char	quote_type;
	int		in_word;

	count = 0;
	i = 0;
	in_quotes = 0;
	in_word = 0;
	while (str[i])
	{
		if (!in_quotes && (str[i] == '"' || str[i] == '\''))
		{
			quote_type = str[i];
			in_quotes = 1;
			if (!in_word)
			{
				count++;
				in_word = 1;
			}
		}
		else if (in_quotes && str[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && ft_isspace(str[i]))
			in_word = 0;
		else if (!in_word)
		{
			count++;
			in_word = 1;
		}
		i++;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:06:11 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/20 11:24:09 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_env_vars(t_tools *tools)
{
	char	**current_env;

	current_env = tools->env;
	while (*current_env)
	{
		ft_printf("%s\n", *current_env);
		current_env++;
	}
}

char	**get_env_paths(char **env, char *var_name)
{
	int		i;
	char	*value;
	char	**paths;

	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], var_name, ft_strlen(var_name)) == 0)
		{
			value = env[i] + ft_strlen(var_name) + 1;
			paths = ft_split(value, ':');
			return (paths);
		}
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_command_args.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 11:38:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:16:54 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

t_cmd_args	*parse_command_args(char *cmd_str)
{
	t_cmd_args	*cmd_args;
	int			i;
	int			j;
	int			start;
	int			in_quotes;
	char		quote_type;
	char		**args;

	if (!cmd_str)
		return (NULL);
	cmd_args = malloc(sizeof(t_cmd_args));
	if (!cmd_args)
		return (NULL);
	args = malloc(sizeof(char *) * (count_args(cmd_str) + 1));
	if (!args)
	{
		free(cmd_args);
		return (NULL);
	}
	i = 0;
	j = 0;
	while (cmd_str[i])
	{
		while (ft_isspace(cmd_str[i]))
			i++;
		if (!cmd_str[i])
			break ;
		start = i;
		in_quotes = 0;
		while (cmd_str[i])
		{
			if (!in_quotes && (cmd_str[i] == '"' || cmd_str[i] == '\''))
			{
				quote_type = cmd_str[i];
				in_quotes = 1;
				i++;
				continue ;
			}
			if (in_quotes && cmd_str[i] == quote_type)
			{
				in_quotes = 0;
				i++;
				continue ;
			}
			if (!in_quotes && ft_isspace(cmd_str[i]))
				break ;
			i++;
		}
		args[j++] = clean_quotes(ft_substr(cmd_str, start, i - start));
	}
	args[j] = NULL;
	cmd_args->argv = args;
	cmd_args->cmd = ft_strdup(args[0]);
	cmd_args->argc = j;
	return (cmd_args);
}

void	print_cmd_args(t_cmd_args *cmd_args)
{
	int	i;

	printf("Command: [%s]\n", cmd_args->cmd);
	printf("Arguments:\n");
	i = 0;
	while (i < cmd_args->argc)
	{
		printf(" %d: [%s]\n", i, cmd_args->argv[i]);
		i++;
	}
}

void	free_cmd_args(t_cmd_args *cmd_args)
{
	if (!cmd_args)
	{
		return ;
	}

	if (cmd_args->cmd)
		free(cmd_args->cmd);

	if (cmd_args->argv)
	{
		int i = 0;
		while (i < cmd_args->argc)
		{
			if (cmd_args->argv[i])
			{
				free(cmd_args->argv[i]);
			}
			i++;
		}
		free(cmd_args->argv);
	}

	free(cmd_args);
}(!cmd_args)
		return (NULL);
	args = malloc(sizeof(char *) * (count_args(cmd_str) + 1));
	if (!args)
	{
		free(cmd_args);
		return (NULL);
	}
	i = 0;
	j = 0;
	while (cmd_str[i])
	{
		while (ft_isspace(cmd_str[i]))
			i++;
		if (!cmd_str[i])
			break ;
		start = i;
		in_quotes = 0;
		while (cmd_str[i])
		{
			if (!in_quotes && (cmd_str[i] == '"' || cmd_str[i] == '\''))
			{
				quote_type = cmd_str[i];
				in_quotes = 1;
				i++;
				continue ;
			}
			if (in_quotes && cmd_str[i] == quote_type)
			{
				in_quotes = 0;
				i++;
				continue ;
			}
			if (!in_quotes && ft_isspace(cmd_str[i]))
				break ;
			i++;
		}
		args[j++] = clean_quotes(ft_substr(cmd_str, start, i - start));
	}
	args[j] = NULL;
	cmd_args->argv = args;
	cmd_args->cmd = ft_strdup(args[0]);
	cmd_args->argc = j;
	return (cmd_args);
}

void	print_cmd_args(t_cmd_args *cmd_args)
{
	int	i;

	printf("Command: [%s]\n", cmd_args->cmd);
	printf("Arguments:\n");
	i = 0;
	while (i < cmd_args->argc)
	{
		printf(" %d: [%s]\n", i, cmd_args->argv[i]);
		i++;
	}
}

void	free_cmd_args(t_cmd_args *cmd_args)
{
	if (!cmd_args)
	{
		return ;
	}

	if (cmd_args->cmd)
		free(cmd_args->cmd);

	if (cmd_args->argv)
	{
		int i = 0;
		while (i < cmd_args->argc)
		{
			if (cmd_args->argv[i])
			{
				free(cmd_args->argv[i]);
			}
			i++;
		}
		free(cmd_args->argv);
	}

	free(cmd_args);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_line.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:30:33 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:20:30 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	print_parsed_command(t_parsed_cmd *cmd)
{
	int	j;
	int	k;
	int	l;
	int	i;

	printf(" parsing results:\n");
	printf(" Full command: [%s]\n", cmd->full_cmd);
	if (cmd->input_count > 0)
	{
		printf(" Input File:\n");
		j = 0;
		while (j < cmd->input_count)
		{
			printf(" %d: [%s]\n", j + 1, cmd->input_file[j]);
			j++;
		}
	}
	if (cmd->output_count > 0)
	{
		printf(" Output File:\n");
		k = 0;
		while (k < cmd->output_count)
		{
			printf(" %d: [%s]\n", k + 1, cmd->output_file[k]);
			k++;
		}
	}
	if (cmd->append_count > 0)
	{
		printf(" Append File:\n");
		l = 0;
		while (l < cmd->append_count)
		{
			printf(" %d: [%s]\n", l + 1, cmd->append_file[l]);
			l++;
		}
	}
	if (cmd->heredoc_count > 0)
	{
		printf(" Heredoc Delimiters:\n");
		i = 0;
		while (i < cmd->heredoc_count)
		{
			printf(" %d: [%s]\n", i + 1, cmd->heredoc_delim[i]);
			i++;
		}
	}
}

void	free_parsed_cmd(t_parsed_cmd *cmd)
{
	int	i;

	if (!cmd)
		return ;
	free(cmd->full_cmd);
	free(cmd->cmd);
	i = 0;
	while (i < cmd->input_count)
	{
		free(cmd->input_file[i]);
		i++;
	}
	free(cmd->input_file);
	i = 0;
	while (i < cmd->output_count)
	{
		free(cmd->output_file[i]);
		i++;
	}
	free(cmd->output_file);
	i = 0;
	while (i < cmd->append_count)
	{
		free(cmd->append_file[i]);
		i++;
	}
	free(cmd->append_file);
	i = 0;
	while (i < cmd->heredoc_count)
	{
		free(cmd->heredoc_delim[i]);
		i++;
	}
	free(cmd->heredoc_delim);
	free(cmd);
}

void	free_cell(t_sep *cell)
{
	t_pip	*current;
	t_pip	*next;

	if (!cell)
	{
		return ;
	}
	current = cell->pipcell;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
			free(current->cmd_pipe);
		free(current);
		current = next;
	}
	if (cell->cmd_sep)
		free(cell->cmd_sep);
	free(cell);
}
void	parsing_line(char *user_input, t_tools *tools)
{
	t_sep			*cell;
	t_pip			*current;
	t_cmd_args		*cmd_args;
	t_parsed_cmd	*parsed_cmd;

	if (!user_input || check_invalid_chars(user_input))
		return ;
	(void)tools;
	cell = create_cell(ft_strdup(user_input));
	if (!cell)
		return ;
	parse_pipes(cell);
	current = cell->pipcell;
	while (current && current->cmd_pipe)
	{
		parsed_cmd = parse_redir(current->cmd_pipe);
		if (parsed_cmd)
		{
			print_parsed_command(parsed_cmd);
			if (parsed_cmd->cmd && *(parsed_cmd->cmd) != '\0')
			{
				cmd_args = parse_command_args(parsed_cmd->cmd);
				if (cmd_args)
				{
					print_cmd_args(cmd_args);
					free_cmd_args(cmd_args);
				}
			}
			free_parsed_cmd(parsed_cmd);
		}
		current = current->next; // Déplacé à l'intérieur de la boucle
	}
	free_cell(cell); // Ajout de free_cell qui manquait
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_line.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:30:33 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:20:30 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	print_parsed_command(t_parsed_cmd *cmd)
{
	int	j;
	int	k;
	int	l;
	int	i;

	printf(" parsing results:\n");
	printf(" Full command: [%s]\n", cmd->full_cmd);
	if (cmd->input_count > 0)
	{
		printf(" Input File:\n");
		j = 0;
		while (j < cmd->input_count)
		{
			printf(" %d: [%s]\n", j + 1, cmd->input_file[j]);
			j++;
		}
	}
	if (cmd->output_count > 0)
	{
		printf(" Output File:\n");
		k = 0;
		while (k < cmd->output_count)
		{
			printf(" %d: [%s]\n", k + 1, cmd->output_file[k]);
			k++;
		}
	}
	if (cmd->append_count > 0)
	{
		printf(" Append File:\n");
		l = 0;
		while (l < cmd->append_count)
		{
			printf(" %d: [%s]\n", l + 1, cmd->append_file[l]);
			l++;
		}
	}
	if (cmd->heredoc_count > 0)
	{
		printf(" Heredoc Delimiters:\n");
		i = 0;
		while (i < cmd->heredoc_count)
		{
			printf(" %d: [%s]\n", i + 1, cmd->heredoc_delim[i]);
			i++;
		}
	}
}

void	free_parsed_cmd(t_parsed_cmd *cmd)
{
	int	i;

	if (!cmd)
		return ;
	free(cmd->full_cmd);
	free(cmd->cmd);
	i = 0;
	while (i < cmd->input_count)
	{
		free(cmd->input_file[i]);
		i++;
	}
	free(cmd->input_file);
	i = 0;
	while (i < cmd->output_count)
	{
		free(cmd->output_file[i]);
		i++;
	}
	free(cmd->output_file);
	i = 0;
	while (i < cmd->append_count)
	{
		free(cmd->append_file[i]);
		i++;
	}
	free(cmd->append_file);
	i = 0;
	while (i < cmd->heredoc_count)
	{
		free(cmd->heredoc_delim[i]);
		i++;
	}
	free(cmd->heredoc_delim);
	free(cmd);
}

void	free_cell(t_sep *cell)
{
	t_pip	*current;
	t_pip	*next;

	if (!cell)
	{
		return ;
	}
	current = cell->pipcell;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
			free(current->cmd_pipe);
		free(current);
		current = next;
	}
	if (cell->cmd_sep)
		free(cell->cmd_sep);
	free(cell);
}
void	parsing_line(char *user_input, t_tools *tools)
{
	t_sep			*cell;
	t_pip			*current;
	t_cmd_args		*cmd_args;
	t_parsed_cmd	*parsed_cmd;

	if (!user_input || check_invalid_chars(user_input))
		return ;
	(void)tools;
	cell = create_cell(ft_strdup(user_input));
	if (!cell)
		return ;
	parse_pipes(cell);
	current = cell->pipcell;
	while (current && current->cmd_pipe)
	{
		parsed_cmd = parse_redir(current->cmd_pipe);
		if (parsed_cmd)
		{
			print_parsed_command(parsed_cmd);
			if (parsed_cmd->cmd && *(parsed_cmd->cmd) != '\0')
			{
				cmd_args = parse_command_args(parsed_cmd->cmd);
				if (cmd_args)
				{
					print_cmd_args(cmd_args);
					free_cmd_args(cmd_args);
				}
			}
			free_parsed_cmd(parsed_cmd);
		}
		current = current->next; // Déplacé à l'intérieur de la boucle
	}
	free_cell(cell); // Ajout de free_cell qui manquait
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 13:04:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/03 12:52:47 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// fonction qui va parser les pipes :
// 1. fait un split pour separer les commandes par pipes
// 2. ensuite on parcours ces commandes et on creer une cellule pour chaque commande
// 3. on parser les redirections
// 4. on finit par stcoker la liste des pipes dans la cellule
void	parse_pipes(t_sep *cell)
{
	char	**pipe_commands;
	t_pip	*current;
	int		i;
	t_pip	*new_pipe;

	if (!cell || !cell->cmd_sep)
		return ;
	pipe_commands = ft_split_pipes(cell->cmd_sep, '|');
	if (!pipe_commands)
		return ;
	i = 0;
	cell->pipcell = NULL;
	while (pipe_commands[i])
	{
		new_pipe = malloc(sizeof(t_pip));
		if (!new_pipe)
		{
			free_str_array(pipe_commands);
			return ;
		}
		new_pipe->cmd_pipe = ft_strdup(pipe_commands[i]);
		new_pipe->redirection = NULL;
		new_pipe->next = NULL;
		new_pipe->prev = NULL;
		if (!cell->pipcell)
			cell->pipcell = new_pipe;
		else
		{
			current = cell->pipcell;
			while (current->next)
				current = current->next;
			current->next = new_pipe;
			new_pipe->prev = current;
		}
		i++;
	}
	free_str_array(pipe_commands);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 13:04:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/03 12:52:47 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// fonction qui va parser les pipes :
// 1. fait un split pour separer les commandes par pipes
// 2. ensuite on parcours ces commandes et on creer une cellule pour chaque commande
// 3. on parser les redirections
// 4. on finit par stcoker la liste des pipes dans la cellule
void	parse_pipes(t_sep *cell)
{
	char	**pipe_commands;
	t_pip	*current;
	int		i;
	t_pip	*new_pipe;

	if (!cell || !cell->cmd_sep)
		return ;
	pipe_commands = ft_split_pipes(cell->cmd_sep, '|');
	if (!pipe_commands)
		return ;
	i = 0;
	cell->pipcell = NULL;
	while (pipe_commands[i])
	{
		new_pipe = malloc(sizeof(t_pip));
		if (!new_pipe)
		{
			free_str_array(pipe_commands);
			return ;
		}
		new_pipe->cmd_pipe = ft_strdup(pipe_commands[i]);
		new_pipe->redirection = NULL;
		new_pipe->next = NULL;
		new_pipe->prev = NULL;
		if (!cell->pipcell)
			cell->pipcell = new_pipe;
		else
		{
			current = cell->pipcell;
			while (current->next)
				current = current->next;
			current->next = new_pipe;
			new_pipe->prev = current;
		}
		i++;
	}
	free_str_array(pipe_commands);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_redir.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:23:25 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static char *find_file_end(char *ptr)
{
    int     in_quotes;
    char    quote_type;
    char    *file_end;

    in_quotes = 0;
    file_end = ptr;
    while (*file_end && (in_quotes || (!ft_isspace(*file_end) && *file_end != '<' && *file_end != '>')))
    {
        if (!in_quotes && (*file_end == '"' || *file_end == '\''))
        {
            quote_type = *file_end;
            in_quotes = 1;
        }
        else if (in_quotes && *file_end == quote_type)
            in_quotes = 0;
        file_end++;
    }
    return (file_end);
}
t_parsed_cmd    *parse_redir(char *input)
{
    t_parsed_cmd    *result;
    char            *ptr;
    int             in_quotes;
    char            quote_type;
    char            *cmd_buffer;
    char            *cmd_ptr;
    char            *file_end;

    if (!input)
        return (NULL);
    result = malloc(sizeof(t_parsed_cmd));
    if (!result)
        return (NULL);
    ft_memset(result, 0, sizeof(t_parsed_cmd));
    result->heredoc_delim = malloc(sizeof(char *) * 10);
    result->input_file = malloc(sizeof(char *) * 10);
    result->output_file = malloc(sizeof(char *) * 10);
    result->append_file = malloc(sizeof(char *) * 10);
    if (!result->heredoc_delim || !result->input_file || !result->output_file || !result->append_file)
        return (NULL);
    result->heredoc_count = 0;
    result->input_count = 0;
    result->output_count = 0;
    result->append_count = 0;
    cmd_buffer = malloc(ft_strlen(input) + 1);
    if (!cmd_buffer)
        return (NULL);
    cmd_ptr = cmd_buffer;
    result->full_cmd = ft_strdup(input);
    ptr = input;
    in_quotes = 0;
    while (*ptr)
    {
        if (!in_quotes && (*ptr == '\'' || *ptr == '"'))
        {
            in_quotes = 1;
            quote_type = *ptr;
            *cmd_ptr++ = *ptr;
        }
        else if (in_quotes && *ptr == quote_type)
        {
            in_quotes = 0;
            *cmd_ptr++ = *ptr;
        }
        else if (!in_quotes)
        {
            if (strncmp(ptr, "<<", 2) == 0)
            {
                ptr += 2;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->heredoc_delim[result->heredoc_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (strncmp(ptr, ">>", 2) == 0)
            {
                ptr += 2;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->append_file[result->append_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (*ptr == '<')
            {
                ptr++;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->input_file[result->input_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (*ptr == '>')
            {
                ptr++;
                while (ft_isspace(*ptr))
                    ptr++;
      /* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_redir.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/09 14:23:25 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static char *find_file_end(char *ptr)
{
    int     in_quotes;
    char    quote_type;
    char    *file_end;

    in_quotes = 0;
    file_end = ptr;
    while (*file_end && (in_quotes || (!ft_isspace(*file_end) && *file_end != '<' && *file_end != '>')))
    {
        if (!in_quotes && (*file_end == '"' || *file_end == '\''))
        {
            quote_type = *file_end;
            in_quotes = 1;
        }
        else if (in_quotes && *file_end == quote_type)
            in_quotes = 0;
        file_end++;
    }
    return (file_end);
}
t_parsed_cmd    *parse_redir(char *input)
{
    t_parsed_cmd    *result;
    char            *ptr;
    int             in_quotes;
    char            quote_type;
    char            *cmd_buffer;
    char            *cmd_ptr;
    char            *file_end;

    if (!input)
        return (NULL);
    result = malloc(sizeof(t_parsed_cmd));
    if (!result)
        return (NULL);
    ft_memset(result, 0, sizeof(t_parsed_cmd));
    result->heredoc_delim = malloc(sizeof(char *) * 10);
    result->input_file = malloc(sizeof(char *) * 10);
    result->output_file = malloc(sizeof(char *) * 10);
    result->append_file = malloc(sizeof(char *) * 10);
    if (!result->heredoc_delim || !result->input_file || !result->output_file || !result->append_file)
        return (NULL);
    result->heredoc_count = 0;
    result->input_count = 0;
    result->output_count = 0;
    result->append_count = 0;
    cmd_buffer = malloc(ft_strlen(input) + 1);
    if (!cmd_buffer)
        return (NULL);
    cmd_ptr = cmd_buffer;
    result->full_cmd = ft_strdup(input);
    ptr = input;
    in_quotes = 0;
    while (*ptr)
    {
        if (!in_quotes && (*ptr == '\'' || *ptr == '"'))
        {
            in_quotes = 1;
            quote_type = *ptr;
            *cmd_ptr++ = *ptr;
        }
        else if (in_quotes && *ptr == quote_type)
        {
            in_quotes = 0;
            *cmd_ptr++ = *ptr;
        }
        else if (!in_quotes)
        {
            if (strncmp(ptr, "<<", 2) == 0)
            {
                ptr += 2;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->heredoc_delim[result->heredoc_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (strncmp(ptr, ">>", 2) == 0)
            {
                ptr += 2;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->append_file[result->append_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (*ptr == '<')
            {
                ptr++;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->input_file[result->input_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else if (*ptr == '>')
            {
                ptr++;
                while (ft_isspace(*ptr))
                    ptr++;
                file_end = find_file_end(ptr);
                result->output_file[result->output_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else
                *cmd_ptr++ = *ptr;
        }
        else
            *cmd_ptr++ = *ptr;
        ptr++;
    }
    *cmd_ptr = '\0';
    result->cmd = ft_strtrim(cmd_buffer, " \t");
    free(cmd_buffer);
    result->heredoc_delim[result->heredoc_count] = NULL;
    result->input_file[result->input_count] = NULL;
    result->output_file[result->output_count] = NULL;
    result->append_file[result->append_count] = NULL;
    return (result);
}
          file_end = find_file_end(ptr);
                result->output_file[result->output_count++] = ft_substr(ptr, 0, file_end - ptr);
                ptr = file_end - 1;
            }
            else
                *cmd_ptr++ = *ptr;
        }
        else
            *cmd_ptr++ = *ptr;
        ptr++;
    }
    *cmd_ptr = '\0';
    result->cmd = ft_strtrim(cmd_buffer, " \t");
    free(cmd_buffer);
    result->heredoc_delim[result->heredoc_count] = NULL;
    result->input_file[result->input_count] = NULL;
    result->output_file[result->output_count] = NULL;
    result->append_file[result->append_count] = NULL;
    return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_pipe_command.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:52:58 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/03 12:53:23 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	print_input_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->input_count <= 0)
		return ;
	ft_printf("Input files:\n");
	i = 0;
	while (i < cmd->input_count)
	{
		ft_printf(" - [%s]\n", cmd->input_file[i]);
		i++;
	}
}

static void	print_output_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->output_count <= 0)
		return ;
	ft_printf("Output files:\n");
	i = 0;
	while (i < cmd->output_count)
	{
		ft_printf(" - [%s]\n", cmd->output_file[i]);
		i++;
	}
}

static void	print_heredoc_delims(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->heredoc_count <= 0)
		return ;
	ft_printf("Heredoc delimiters:\n");
	i = 0;
	while (i < cmd->heredoc_count)
	{
		ft_printf(" - [%s]\n", cmd->heredoc_delim[i]);
		i++;
	}
}

static void	print_append_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->append_count <= 0)
		return ;
	ft_printf("Append files:\n");
	i = 0;
	while (i < cmd->append_count)
	{
		ft_printf(" - [%s]\n", cmd->append_file[i]);
		i++;
	}
}

void	print_pipe_command(t_pip *pipe_cmd, int pipe_num)
{
	if (!pipe_cmd || !pipe_cmd->redirection)
		return ;
	ft_printf("\n=== Pipe command %d ===\n", pipe_num);
	ft_printf("Command: [%s]\n", pipe_cmd->cmd_pipe);
	print_input_files(pipe_cmd->redirection);
	print_output_files(pipe_cmd->redirection);
	print_heredoc_delims(pipe_cmd->redirection);
	print_append_files(pipe_cmd->redirection);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_pipe_command.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:52:58 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/03 12:53:23 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	print_input_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->input_count <= 0)
		return ;
	ft_printf("Input files:\n");
	i = 0;
	while (i < cmd->input_count)
	{
		ft_printf(" - [%s]\n", cmd->input_file[i]);
		i++;
	}
}

static void	print_output_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->output_count <= 0)
		return ;
	ft_printf("Output files:\n");
	i = 0;
	while (i < cmd->output_count)
	{
		ft_printf(" - [%s]\n", cmd->output_file[i]);
		i++;
	}
}

static void	print_heredoc_delims(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->heredoc_count <= 0)
		return ;
	ft_printf("Heredoc delimiters:\n");
	i = 0;
	while (i < cmd->heredoc_count)
	{
		ft_printf(" - [%s]\n", cmd->heredoc_delim[i]);
		i++;
	}
}

static void	print_append_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->append_count <= 0)
		return ;
	ft_printf("Append files:\n");
	i = 0;
	while (i < cmd->append_count)
	{
		ft_printf(" - [%s]\n", cmd->append_file[i]);
		i++;
	}
}

void	print_pipe_command(t_pip *pipe_cmd, int pipe_num)
{
	if (!pipe_cmd || !pipe_cmd->redirection)
		return ;
	ft_printf("\n=== Pipe command %d ===\n", pipe_num);
	ft_printf("Command: [%s]\n", pipe_cmd->cmd_pipe);
	print_input_files(pipe_cmd->redirection);
	print_output_files(pipe_cmd->redirection);
	print_heredoc_delims(pipe_cmd->redirection);
	print_append_files(pipe_cmd->redirection);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:58:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/31 11:20:51 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// but de cette fonction :
// 1. recuperer les chemins a partir de PATH au demarrage
// 2. on setup les signaux (comme crl-C qui interrpomt la commande en cours et affiche une nouvelle ligne de promopt)
// 3. gestion du ctrl-D(signale la fin de l entree utilisateur ,
//	c est pour quitter le programme)
// 4. on ignore les lignes vides
// 5. si la commande n est pas vide on l ajoute a lhistorique
// 7 traitement des autres commandes
// 8. on libere la memoire et on nettoie lhistoique
void	loop_prompt(t_tools *tools, char **env)
{
	char	*user_input;
	char	**paths;

	paths = get_env_paths(env, "PATH");
	if (!paths)
	{
		ft_printf("Erreur : PATH non trouvé.\n");
		return ;
	}
	setup_signals();
	while (1)
	{
		user_input = get_user_input();
		if (!user_input)
		{
			ft_printf("\nExit\n");
			break ;
		}
		if (user_input[0] == '\0')
		{
			free(user_input);
			continue ;
		}
		parsing_line(user_input, tools);
		free(user_input);
	}
	rl_clear_history();
	free_str_array(paths);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:58:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/31 11:20:51 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// but de cette fonction :
// 1. recuperer les chemins a partir de PATH au demarrage
// 2. on setup les signaux (comme crl-C qui interrpomt la commande en cours et affiche une nouvelle ligne de promopt)
// 3. gestion du ctrl-D(signale la fin de l entree utilisateur ,
//	c est pour quitter le programme)
// 4. on ignore les lignes vides
// 5. si la commande n est pas vide on l ajoute a lhistorique
// 7 traitement des autres commandes
// 8. on libere la memoire et on nettoie lhistoique
void	loop_prompt(t_tools *tools, char **env)
{
	char	*user_input;
	char	**paths;

	paths = get_env_paths(env, "PATH");
	if (!paths)
	{
		ft_printf("Erreur : PATH non trouvé.\n");
		return ;
	}
	setup_signals();
	while (1)
	{
		user_input = get_user_input();
		if (!user_input)
		{
			ft_printf("\nExit\n");
			break ;
		}
		if (user_input[0] == '\0')
		{
			free(user_input);
			continue ;
		}
		parsing_line(user_input, tools);
		free(user_input);
	}
	rl_clear_history();
	free_str_array(paths);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quotes.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:04:34 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/04 10:40:57 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

char	*clean_quotes(char *str)
{
	char *result;
	int i;
	int j;
	int in_quotes;
	char quote_type;

	if (!str)
		return (NULL);
	result = malloc(sizeof(char) * (ft_strlen(str) + 1));
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	in_quotes = 0;
	while (str[i])
	{
		if (!in_quotes && (str[i] == '"' || str[i] == '\''))
		{
			quote_type = str[i];
			in_quotes = 1;
		}
		else if (in_quotes && str[i] == quote_type)
			in_quotes = 0;
		else
			result[j++] = str[i];
		i++;
	}
	result[j] = '\0';
	return (result);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quotes.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:04:34 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/04 10:40:57 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

char	*clean_quotes(char *str)
{
	char *result;
	int i;
	int j;
	int in_quotes;
	char quote_type;

	if (!str)
		return (NULL);
	result = malloc(sizeof(char) * (ft_strlen(str) + 1));
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	in_quotes = 0;
	while (str[i])
	{
		if (!in_quotes && (str[i] == '"' || str[i] == '\''))
		{
			quote_type = str[i];
			in_quotes = 1;
		}
		else if (in_quotes && str[i] == quote_type)
			in_quotes = 0;
		else
			result[j++] = str[i];
		i++;
	}
	result[j] = '\0';
	return (result);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sep.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 15:17:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/09 14:12:29 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// fonction qui creer une cellule de la liste chainnee
t_sep	*create_cell(char *cmd_sep)
{
	t_sep	*cell;

	cell = malloc(sizeof(t_sep));
	if (!cell)
		return (NULL);
	cell->prev = NULL;
	cell->next = NULL;
	cell->pipcell = NULL;
	cell->cmd_sep = cmd_sep;
	return (cell);
}

// Cette fonction ajoutera une cellule dans la liste chaînée à la position spécifiée.
// Si la liste est vide,
// la nouvelle cellule sera simplement le premier élément de la liste.

t_sep	*add_cell(t_sep *list, char *cmd_sep, int pos)
{
	t_sep	*prec;
	t_sep	*cur;
	t_sep	*cell;
	int		i;

	cell = create_cell(cmd_sep);
	if (!list)
		return (cell);
	cur = list;
	i = 0;
	while (i < pos && cur != NULL)
	{
		prec = cur;
		cur = cur->next;
		i++;
	}
	if (prec != NULL)
	{
		prec->next = cell;
		cell->prev = prec;
	}
	if (cur != NULL)
	{
		cell->next = cur;
		cur->prev = cell;
	}
	return (list);
}

/* void	free_cell(t_sep *cell)
{
	t_pip	*current;
	t_pip	*next;

	if (!cell)
		return ;
	current = cell->pipcell;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
			free(current->cmd_pipe);
		// Ne pas libérer current->redirection ici
		// car il sera libéré dans free_cmd_args
		free(current);
		current = next;
	}
	if (cell->cmd_sep)
		free(cell->cmd_sep);
	free(cell);
} */

static int	is_invalid_char(char c)
{
	return (c == '\\' || c == ';');
}

/*
** check_invalid_chars: Vérifie les caractères invalides dans la commande
** Retourne 1 si un caractère invalide est trouvé hors guillemets
** Retourne 0 si la commande est valide
*/

int	check_invalid_chars(const char *cmd)
{
	int		i;
	int		in_quotes;
	char	quote_type;

	if (!cmd)
		return (1);
	i = 0;
	in_quotes = 0;
	quote_type = 0;
	while (cmd[i])
	{
		if (!in_quotes && (cmd[i] == '\'' || cmd[i] == '"'))
		{
			in_quotes = 1;
			quote_type = cmd[i];
		}
		else if (in_quotes && cmd[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && is_invalid_char(cmd[i]))
			return (1);
		i++;
	}
	if (in_quotes)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sep.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 15:17:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/09 14:12:29 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// fonction qui creer une cellule de la liste chainnee
t_sep	*create_cell(char *cmd_sep)
{
	t_sep	*cell;

	cell = malloc(sizeof(t_sep));
	if (!cell)
		return (NULL);
	cell->prev = NULL;
	cell->next = NULL;
	cell->pipcell = NULL;
	cell->cmd_sep = cmd_sep;
	return (cell);
}

// Cette fonction ajoutera une cellule dans la liste chaînée à la position spécifiée.
// Si la liste est vide,
// la nouvelle cellule sera simplement le premier élément de la liste.

t_sep	*add_cell(t_sep *list, char *cmd_sep, int pos)
{
	t_sep	*prec;
	t_sep	*cur;
	t_sep	*cell;
	int		i;

	cell = create_cell(cmd_sep);
	if (!list)
		return (cell);
	cur = list;
	i = 0;
	while (i < pos && cur != NULL)
	{
		prec = cur;
		cur = cur->next;
		i++;
	}
	if (prec != NULL)
	{
		prec->next = cell;
		cell->prev = prec;
	}
	if (cur != NULL)
	{
		cell->next = cur;
		cur->prev = cell;
	}
	return (list);
}

/* void	free_cell(t_sep *cell)
{
	t_pip	*current;
	t_pip	*next;

	if (!cell)
		return ;
	current = cell->pipcell;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
			free(current->cmd_pipe);
		// Ne pas libérer current->redirection ici
		// car il sera libéré dans free_cmd_args
		free(current);
		current = next;
	}
	if (cell->cmd_sep)
		free(cell->cmd_sep);
	free(cell);
} */

static int	is_invalid_char(char c)
{
	return (c == '\\' || c == ';');
}

/*
** check_invalid_chars: Vérifie les caractères invalides dans la commande
** Retourne 1 si un caractère invalide est trouvé hors guillemets
** Retourne 0 si la commande est valide
*/

int	check_invalid_chars(const char *cmd)
{
	int		i;
	int		in_quotes;
	char	quote_type;

	if (!cmd)
		return (1);
	i = 0;
	in_quotes = 0;
	quote_type = 0;
	while (cmd[i])
	{
		if (!in_quotes && (cmd[i] == '\'' || cmd[i] == '"'))
		{
			in_quotes = 1;
			quote_type = cmd[i];
		}
		else if (in_quotes && cmd[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && is_invalid_char(cmd[i]))
			return (1);
		i++;
	}
	if (in_quotes)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 11:58:53 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/03 12:55:12 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// but de cette fonction :
// 1. Utilisation de readline qui gère automatiquement le prompt
// 2. // Si input est NULL (Ctrl-D), on retourne NULL
// 3. Ajouter la commande à l'historique si elle n'est pas vide

char	*get_user_input(void)
{
	char	*input;

	input = readline("~$ ");
	if (!input)
		return (NULL);
	if (input[0] != '\0')
		add_history(input);
	return (input);
}

void	handle_signal(int sig)
{
	if (sig == SIGINT)
	{
		rl_replace_line("", 0);
		write(1, "\n", 1);
		rl_on_new_line();
		rl_redisplay();
	}
}

void	setup_signals(void)
{
	signal(SIGINT, handle_signal);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 11:58:53 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/03 12:55:12 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// but de cette fonction :
// 1. Utilisation de readline qui gère automatiquement le prompt
// 2. // Si input est NULL (Ctrl-D), on retourne NULL
// 3. Ajouter la commande à l'historique si elle n'est pas vide

char	*get_user_input(void)
{
	char	*input;

	input = readline("~$ ");
	if (!input)
		return (NULL);
	if (input[0] != '\0')
		add_history(input);
	return (input);
}

void	handle_signal(int sig)
{
	if (sig == SIGINT)
	{
		rl_replace_line("", 0);
		write(1, "\n", 1);
		rl_on_new_line();
		rl_redisplay();
	}
}

void	setup_signals(void)
{
	signal(SIGINT, handle_signal);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 11:25:48 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/27 16:16:00 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_str_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

int	ft_isspace(int c)
{
	if (c == 32)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 11:25:48 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/27 16:16:00 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_str_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

int	ft_isspace(int c)
{
	if (c == 32)
		return (1);
	return (0);
}
