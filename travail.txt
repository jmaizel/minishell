/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd_args_parse.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 11:38:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 18:00:58 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static int	skip_spaces(char *cmd_str, int i)
{
	while (cmd_str[i] && ft_isspace(cmd_str[i]))
		i++;
	return (i);
}

static t_cmd_args	*init_cmd_args(char *cmd_str, char ***args)
{
	t_cmd_args	*cmd_args;

	if (!cmd_str)
		return (NULL);
	cmd_args = malloc(sizeof(t_cmd_args));
	if (!cmd_args)
		return (NULL);
	*args = malloc(sizeof(char *) * (count_args(cmd_str) + 1));
	if (!*args)
	{
		free(cmd_args);
		return (NULL);
	}
	return (cmd_args);
}

static int	fill_args_list(char *cmd_str, char **args, t_cmd_args *cmd_args)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (cmd_str[i])
	{
		i = skip_spaces(cmd_str, i);
		if (!cmd_str[i])
			break ;
		i = extract_arg(args, cmd_str, i, &j);
		if (!i)
		{
			free_str_array(args);
			free(cmd_args);
			return (0);
		}
	}
	args[j] = NULL;
	return (j);
}

t_cmd_args	*parse_command_args(char *cmd_str)
{
	t_cmd_args	*cmd_args;
	char		**args;
	int			arg_count;

	cmd_args = init_cmd_args(cmd_str, &args);
	if (!cmd_args)
		return (NULL);
	arg_count = fill_args_list(cmd_str, args, cmd_args);
	if (!arg_count)
		return (NULL);
	cmd_args->argv = args;
	cmd_args->cmd = ft_strdup(args[0]);
	cmd_args->argc = arg_count;
	return (cmd_args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd_args_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 11:38:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/27 14:27:57 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static int	get_token_length(char *cmd_str, int i)
{
	int		start;
	int		in_quotes;
	char	quote_type;

	start = i;
	in_quotes = 0;
	quote_type = 0;
	while (cmd_str[i])
	{
		if (!in_quotes && (cmd_str[i] == '"' || cmd_str[i] == '\''))
		{
			quote_type = cmd_str[i];
			in_quotes = 1;
		}
		else if (in_quotes && cmd_str[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && ft_isspace(cmd_str[i]))
			break ;
		i++;
	}
	return (i - start);
}

int	extract_arg(char **args, char *cmd_str, int i, int *j)
{
	int		start;
	int		len;
	char	*arg;
	char	*cleaned;

	start = i;
	len = get_token_length(cmd_str, i);
	arg = ft_substr(cmd_str, start, len);
	if (!arg)
		return (0);
	cleaned = clean_quotes(arg);
	free(arg);
	if (!cleaned)
		return (0);
	args[*j] = cleaned;
	(*j)++;
	return (start + len);
}

/* void	print_cmd_args(t_cmd_args *cmd_args)
{
	int	i;

	if (!cmd_args)
		return ;
	printf("Command: [%s]\n", cmd_args->cmd);
	printf("Arguments:\n");
	i = 0;
	while (i < cmd_args->argc)
	{
		printf(" %d: [%s]\n", i, cmd_args->argv[i]);
		i++;
	}
} */

void	free_cmd_args(t_cmd_args *cmd_args)
{
	int	i;

	if (!cmd_args)
		return ;
	if (cmd_args->cmd)
		free(cmd_args->cmd);
	if (cmd_args->argv)
	{
		i = 0;
		while (i < cmd_args->argc)
		{
			if (cmd_args->argv[i])
				free(cmd_args->argv[i]);
			i++;
		}
		free(cmd_args->argv);
	}
	free(cmd_args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   count_args.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:07:09 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/25 14:24:23 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	handle_quote(char c, int *in_quotes, char *quote_type, int *in_word)
{
	if (!(*in_quotes))
	{
		*quote_type = c;
		*in_quotes = 1;
		if (!(*in_word))
		{
			*in_word = 1;
		}
	}
	else if (c == *quote_type)
		*in_quotes = 0;
}

static void	handle_word(char c, int *count, int *in_word, int in_quotes)
{
	if (!in_quotes && ft_isspace(c))
		*in_word = 0;
	else if (!(*in_word))
	{
		(*count)++;
		*in_word = 1;
	}
}

int	count_args(char *str)
{
	int		count;
	int		i;
	int		in_quotes;
	char	quote_type;
	int		in_word;

	count = 0;
	i = 0;
	in_quotes = 0;
	in_word = 0;
	while (str[i])
	{
		if (!in_quotes && (str[i] == '"' || str[i] == '\''))
			handle_quote(str[i], &in_quotes, &quote_type, &in_word);
		else
			handle_word(str[i], &count, &in_word, in_quotes);
		i++;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:06:11 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/01/20 11:24:09 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	print_env_vars(t_tools *tools)
{
	char	**current_env;

	current_env = tools->env;
	while (*current_env)
	{
		ft_printf("%s\n", *current_env);
		current_env++;
	}
}

char	**get_env_paths(char **env, char *var_name)
{
	int		i;
	char	*value;
	char	**paths;

	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], var_name, ft_strlen(var_name)) == 0)
		{
			value = env[i] + ft_strlen(var_name) + 1;
			paths = ft_split(value, ':');
			return (paths);
		}
		i++;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansion_core.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 13:47:02 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:25:33 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static size_t	copy_value(char **result, size_t j, char *value, size_t *size)
{
	size_t	len;

	len = ft_strlen(value);
	*result = resize_buffer(*result, size, j + len);
	if (!*result)
		return (0);
	ft_memcpy(*result + j, value, len);
	free(value);
	return (j + len);
}

static int	process_dollar(const char *str, t_expand *exp, char **result,
		t_tools *tools)
{
	char	*value;

	(exp->i)++;
	if (ft_isalpha(str[exp->i]) || str[exp->i] == '_' || str[exp->i] == '?')
	{
		value = handle_variable(str, &(exp->i), tools);
		if (!value)
			return (0);
		exp->j = copy_value(result, exp->j, value, &(exp->size));
		if (!*result)
			return (0);
	}
	else
	{
		(*result)[exp->j++] = '$';
	}
	return (1);
}

static int	handle_char(const char *str, char **result, t_expand *exp,
		t_tools *tools)
{
	if (str[exp->i] == '\'')
	{
		(*result)[exp->j++] = str[exp->i++];
		exp->in_quotes = !(exp->in_quotes);
	}
	else if (str[exp->i] == '$' && !(exp->in_quotes))
	{
		if (!process_dollar(str, exp, result, tools))
			return (0);
	}
	else
		(*result)[exp->j++] = str[exp->i++];
	*result = resize_buffer(*result, &exp->size, exp->j);
	if (!*result)
		return (0);
	return (1);
}

char	*expand_str(const char *str, t_tools *tools)
{
	char		*result;
	t_expand	exp;

	exp.size = 2048;
	if (!str || !tools || !tools->env)
		return (ft_strdup(""));
	result = ft_calloc(exp.size, sizeof(char));
	if (!result)
		return (NULL);
	exp.i = 0;
	exp.j = 0;
	exp.in_quotes = 0;
	while (str[exp.i])
	{
		if (!handle_char(str, &result, &exp, tools))
			return (NULL);
	}
	result[exp.j] = '\0';
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansion_utls.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 13:47:02 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:25:48 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static char	*ft_realloc(char *ptr, size_t old_size, size_t new_size)
{
	char	*new_ptr;

	if (!ptr)
		return (malloc(new_size));
	if (new_size <= old_size)
		return (ptr);
	new_ptr = malloc(new_size);
	if (!new_ptr)
	{
		free(ptr);
		return (NULL);
	}
	ft_memcpy(new_ptr, ptr, old_size);
	free(ptr);
	return (new_ptr);
}

char	*resize_buffer(char *result, size_t *size, size_t needed_size)
{
	char	*new_result;

	if (needed_size >= *size)
	{
		new_result = ft_realloc(result, *size, *size + needed_size + 1024);
		if (!new_result)
		{
			free(result);
			return (NULL);
		}
		*size += needed_size + 1024;
		return (new_result);
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansion_variable.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 13:47:02 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:26:02 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

char	*get_var_value(const char *var_name, char **env)
{
	int		i;
	size_t	len;

	if (!var_name || !env)
		return (ft_strdup(""));
	len = ft_strlen(var_name);
	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], var_name, len) == 0 && env[i][len] == '=')
			return (ft_strdup(env[i] + len + 1));
		i++;
	}
	return (ft_strdup(""));
}

static char	*convert_exit_status(int exit_code)
{
	char	temp[12];
	int		i;

	i = 0;
	if (exit_code == 0)
		temp[i++] = '0';
	else
	{
		while (exit_code > 0)
		{
			temp[i++] = (exit_code % 10) + '0';
			exit_code /= 10;
		}
	}
	temp[i] = '\0';
	return (ft_strdup(temp));
}

static char	*extract_var_name(const char *str, size_t *i)
{
	size_t	start;
	char	*var_name;

	start = *i;
	while (str[*i] && (ft_isalnum(str[*i]) || str[*i] == '_'))
		(*i)++;
	var_name = ft_substr(str, start, *i - start);
	return (var_name);
}

char	*handle_variable(const char *str, size_t *i, t_tools *tools)
{
	char	*var_name;
	char	*value;

	if (str[*i] == '?')
	{
		(*i)++;
		return (convert_exit_status(tools->exit_code));
	}
	var_name = extract_var_name(str, i);
	if (!var_name)
		return (NULL);
	value = get_var_value(var_name, tools->env);
	free(var_name);
	return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_cleanup.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:30:33 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:26:45 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	free_redir_arrays(t_parsed_cmd *cmd)
{
	int	i;

	i = 0;
	while (i < cmd->input_count)
		free(cmd->input_file[i++]);
	free(cmd->input_file);
	i = 0;
	while (i < cmd->output_count)
		free(cmd->output_file[i++]);
	free(cmd->output_file);
	i = 0;
	while (i < cmd->append_count)
		free(cmd->append_file[i++]);
	free(cmd->append_file);
	i = 0;
	while (i < cmd->heredoc_count)
		free(cmd->heredoc_delim[i++]);
	free(cmd->heredoc_delim);
}

void	free_parsed_cmd(t_parsed_cmd *cmd)
{
	if (!cmd)
		return ;
	free(cmd->full_cmd);
	free(cmd->cmd);
	free_redir_arrays(cmd);
	free(cmd);
}

void	free_cell(t_sep *cell)
{
	t_pip	*current;
	t_pip	*next;

	if (!cell)
		return ;
	current = cell->pipcell;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
			free(current->cmd_pipe);
		free(current);
		current = next;
	}
	if (cell->cmd_sep)
		free(cell->cmd_sep);
	free(cell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_display.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:30:33 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/27 14:30:35 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/* static void	print_redirect_files(char **files, int count, const char *label)
{
	int	i;

	if (count > 0)
	{
		printf(" %s:\n", label);
		i = 0;
		while (i < count)
		{
			printf(" %d: [%s]\n", i + 1, files[i]);
			i++;
		}
	}
} */

/* static void	print_redirections(t_parsed_cmd *cmd, int type)
{
	if (type == 0)
		print_redirect_files(cmd->input_file, cmd->input_count, "Input File");
	else if (type == 1)
		print_redirect_files(cmd->output_file, cmd->output_count,
			"Output File");
	else if (type == 2)
		print_redirect_files(cmd->append_file, cmd->append_count,
			"Append File");
	else if (type == 3)
		print_redirect_files(cmd->heredoc_delim, cmd->heredoc_count,
			"Heredoc Delimiters");
} */

/* void	print_parsed_command(t_parsed_cmd *cmd)
{
	printf(" parsing results:\n");
	printf(" Full command: [%s]\n", cmd->full_cmd);
	print_redirections(cmd, 0);
	print_redirections(cmd, 1);
	print_redirections(cmd, 2);
	print_redirections(cmd, 3);
} */

static void	process_command(t_pip *current)
{
	t_parsed_cmd	*parsed_cmd;
	t_cmd_args		*cmd_args;

	parsed_cmd = parse_redir(current->cmd_pipe);
	if (parsed_cmd)
	{
		//print_parsed_command(parsed_cmd);
		if (parsed_cmd->cmd && *(parsed_cmd->cmd) != '\0')
		{
			cmd_args = parse_command_args(parsed_cmd->cmd);
			if (cmd_args)
			{
				//print_cmd_args(cmd_args);
				free_cmd_args(cmd_args);
			}
		}
		free_parsed_cmd(parsed_cmd);
	}
}

void	parsing_line(char *user_input, t_tools *tools)
{
	t_sep	*cell;
	t_pip	*current;

	if (!user_input || check_invalid_chars(user_input))
		return ;
	(void)tools;
	cell = create_cell(ft_strdup(user_input));
	if (!cell)
		return ;
	parse_pipes(cell);
	current = cell->pipcell;
	while (current && current->cmd_pipe)
	{
		process_command(current);
		current = current->next;
	}
	free_cell(cell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 13:04:29 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:10:27 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_pip	*create_pipe_node(char *cmd_content)
{
	t_pip	*new_pipe;

	new_pipe = malloc(sizeof(t_pip));
	if (!new_pipe)
		return (NULL);
	new_pipe->cmd_pipe = ft_strdup(cmd_content);
	new_pipe->redirection = NULL;
	new_pipe->next = NULL;
	new_pipe->prev = NULL;
	return (new_pipe);
}

static void	add_pipe_to_cell(t_sep *cell, t_pip *new_pipe)
{
	t_pip	*current;

	if (!cell->pipcell)
		cell->pipcell = new_pipe;
	else
	{
		current = cell->pipcell;
		while (current->next)
			current = current->next;
		current->next = new_pipe;
		new_pipe->prev = current;
	}
}

void	parse_pipes(t_sep *cell)
{
	char	**pipe_commands;
	t_pip	*new_pipe;
	int		i;

	if (!cell || !cell->cmd_sep)
		return ;
	pipe_commands = ft_split_pipes(cell->cmd_sep, '|');
	if (!pipe_commands)
		return ;
	i = 0;
	cell->pipcell = NULL;
	while (pipe_commands[i])
	{
		new_pipe = create_pipe_node(pipe_commands[i]);
		if (!new_pipe)
		{
			free_str_array(pipe_commands);
			return ;
		}
		add_pipe_to_cell(cell, new_pipe);
		i++;
	}
	free_str_array(pipe_commands);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_redir.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 17:56:48 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	finalize_result(t_parsed_cmd *result, char *cmd_buffer)
{
	result->cmd = ft_strtrim(cmd_buffer, " \t");
	free(cmd_buffer);
	result->heredoc_delim[result->heredoc_count] = NULL;
	result->input_file[result->input_count] = NULL;
	result->output_file[result->output_count] = NULL;
	result->append_file[result->append_count] = NULL;
}

static t_parsed_cmd	*init_and_prepare(char *input)
{
	t_parsed_cmd	*result;
	char			*cmd_buffer;

	if (!input || !check_redir_syntax(input))
		return (NULL);
	result = init_parsed_cmd();
	if (!result)
		return (NULL);
	cmd_buffer = malloc(ft_strlen(input) + 1);
	if (!cmd_buffer)
	{
		free_parsed_cmd(result);
		return (NULL);
	}
	result->full_cmd = ft_strdup(input);
	return (result);
}

static void	parse_redir_loop(char *input, t_parsed_cmd *result, char *cmd_buf)
{
	char	*ptr;
	char	*cmd_ptr;
	int		in_quotes;
	char	quote_type;

	ptr = input;
	cmd_ptr = cmd_buf;
	in_quotes = 0;
	while (*ptr)
	{
		if (!in_quotes && (*ptr == '\'' || *ptr == '"'))
			process_quotes(&cmd_ptr, &ptr, &in_quotes, &quote_type);
		else if (in_quotes && *ptr == quote_type)
			process_quotes(&cmd_ptr, &ptr, &in_quotes, &quote_type);
		else if (!in_quotes)
			process_redirection(&ptr, result, &cmd_ptr);
		else
			*cmd_ptr++ = *ptr;
		ptr++;
	}
	*cmd_ptr = '\0';
}

t_parsed_cmd	*parse_redir(char *input)
{
	t_parsed_cmd	*result;
	char			*cmd_buffer;

	result = init_and_prepare(input);
	if (!result)
		return (NULL);
	cmd_buffer = malloc(ft_strlen(input) + 1);
	if (!cmd_buffer)
		return (free_parsed_cmd(result), NULL);
	parse_redir_loop(input, result, cmd_buffer);
	finalize_result(result, cmd_buffer);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   print_pipe_command.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:52:58 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/27 14:29:00 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

/* static void	print_input_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->input_count <= 0)
		return ;
	ft_printf("Input files:\n");
	i = 0;
	while (i < cmd->input_count)
	{
		ft_printf(" - [%s]\n", cmd->input_file[i]);
		i++;
	}
}

static void	print_output_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->output_count <= 0)
		return ;
	ft_printf("Output files:\n");
	i = 0;
	while (i < cmd->output_count)
	{
		ft_printf(" - [%s]\n", cmd->output_file[i]);
		i++;
	}
}

static void	print_heredoc_delims(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->heredoc_count <= 0)
		return ;
	ft_printf("Heredoc delimiters:\n");
	i = 0;
	while (i < cmd->heredoc_count)
	{
		ft_printf(" - [%s]\n", cmd->heredoc_delim[i]);
		i++;
	}
}

static void	print_append_files(t_parsed_cmd *cmd)
{
	int	i;

	if (cmd->append_count <= 0)
		return ;
	ft_printf("Append files:\n");
	i = 0;
	while (i < cmd->append_count)
	{
		ft_printf(" - [%s]\n", cmd->append_file[i]);
		i++;
	}
}

void	print_pipe_command(t_pip *pipe_cmd, int pipe_num)
{
	if (!pipe_cmd || !pipe_cmd->redirection)
		return ;
	ft_printf("\n=== Pipe command %d ===\n", pipe_num);
	ft_printf("Command: [%s]\n", pipe_cmd->cmd_pipe);
	print_input_files(pipe_cmd->redirection);
	print_output_files(pipe_cmd->redirection);
	print_heredoc_delims(pipe_cmd->redirection);
	print_append_files(pipe_cmd->redirection);
} */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:56:22 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 17:59:07 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

void	process_quotes(char **cmd_ptr, char **ptr, int *in_quotes,
		char *quote_type)
{
	if (!*in_quotes)
	{
		*in_quotes = 1;
		*quote_type = **ptr;
	}
	else
		*in_quotes = 0;
	**cmd_ptr = **ptr;
	(*cmd_ptr)++;
}

void	process_redirection(char **ptr, t_parsed_cmd *result, char **cmd_ptr)
{
	if (ft_strncmp(*ptr, "<<", 2) == 0 || ft_strncmp(*ptr, ">>", 2) == 0)
		handle_redirection(ptr, result, 2);
	else if (**ptr == '<')
		handle_redirection(ptr, result, 0);
	else if (**ptr == '>')
		handle_redirection(ptr, result, 1);
	else
	{
		**cmd_ptr = **ptr;
		(*cmd_ptr)++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 13:58:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/25 14:38:45 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

// but de cette fonction :
// 1. recuperer les chemins a partir de PATH au demarrage
// 2. on setup les signaux (comme crl-C qui interrpomt la commande en cours et
// affiche une nouvelle ligne de promopt)
// 3. gestion du ctrl-D(signale la fin de l entree utilisateur ,
//	c est pour quitter le programme)
// 4. on ignore les lignes vides
// 5. si la commande n est pas vide on l ajoute a lhistorique
// 7 traitement des autres commandes
// 8. on libere la memoire et on nettoie lhistoique
static void	handle_prompt_loop(t_tools *tools)
{
	char	*user_input;

	while (1)
	{
		user_input = get_user_input();
		if (!user_input)
		{
			ft_printf("\nExit\n");
			break ;
		}
		if (user_input[0] == '\0')
		{
			free(user_input);
			continue ;
		}
		parsing_line(user_input, tools);
		free(user_input);
	}
}

void	loop_prompt(t_tools *tools, char **env)
{
	char	**paths;

	paths = get_env_paths(env, "PATH");
	if (!paths)
	{
		ft_printf("Erreur : PATH non trouvé.\n");
		return ;
	}
	setup_interactive_signals();
	handle_prompt_loop(tools);
	rl_clear_history();
	free_str_array(paths);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   quotes.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 12:04:34 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/25 18:14:08 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

static void	process_quote(char *str, int *i, int *in_quotes, char *quote_type)
{
	if (!*in_quotes && (str[*i] == '"' || str[*i] == '\''))
	{
		*quote_type = str[*i];
		*in_quotes = 1;
	}
	else if (*in_quotes && str[*i] == *quote_type)
		*in_quotes = 0;
}

static char	*allocate_result_buffer(char *str)
{
	char	*result;

	if (!str)
		return (NULL);
	result = malloc(sizeof(char) * (ft_strlen(str) + 1));
	if (!result)
		return (NULL);
	return (result);
}

char	*clean_quotes(char *str)
{
	char	*result;
	int		i;
	int		j;
	int		in_quotes;
	char	quote_type;

	result = allocate_result_buffer(str);
	if (!result)
		return (NULL);
	i = 0;
	j = 0;
	in_quotes = 0;
	while (str[i])
	{
		process_quote(str, &i, &in_quotes, &quote_type);
		if (!((!in_quotes && (str[i] == '"' || str[i] == '\'')) || (in_quotes
					&& str[i] == quote_type)))
			result[j++] = str[i];
		i++;
	}
	result[j] = '\0';
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_file.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:27:41 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

char	*find_file_end(char *ptr)
{
	int		in_quotes;
	char	quote_type;
	char	*file_end;

	in_quotes = 0;
	file_end = ptr;
	while (*file_end && (in_quotes || (!ft_isspace(*file_end)
				&& *file_end != '<' && *file_end != '>')))
	{
		if (!in_quotes && (*file_end == '"' || *file_end == '\''))
		{
			quote_type = *file_end;
			in_quotes = 1;
		}
		else if (in_quotes && *file_end == quote_type)
			in_quotes = 0;
		file_end++;
	}
	return (file_end);
}

void	handle_redirection(char **ptr, t_parsed_cmd *result, int type)
{
	char	*file_end;

	if (type == 2)
		*ptr += 2;
	else
		(*ptr)++;
	while (ft_isspace(**ptr))
		(*ptr)++;
	file_end = find_file_end(*ptr);
	if (type == 0)
		result->input_file[result->input_count++] = ft_substr(*ptr, 0, file_end
				- *ptr);
	else if (type == 1)
		result->output_file[result->output_count++] = ft_substr(*ptr, 0,
				file_end - *ptr);
	else if (type == 2)
	{
		if ((*ptr)[-2] == '<')
			result->heredoc_delim[result->heredoc_count++] = ft_substr(*ptr, 0,
					file_end - *ptr);
		else
			result->append_file[result->append_count++] = ft_substr(*ptr, 0,
					file_end - *ptr);
	}
	*ptr = file_end - 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_init.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/25 14:27:31 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

#define MAX_REDIR 10

t_parsed_cmd	*init_parsed_cmd(void)
{
	t_parsed_cmd	*result;

	result = malloc(sizeof(t_parsed_cmd));
	if (!result)
		return (NULL);
	ft_memset(result, 0, sizeof(t_parsed_cmd));
	result->heredoc_delim = malloc(sizeof(char *) * MAX_REDIR);
	result->input_file = malloc(sizeof(char *) * MAX_REDIR);
	result->output_file = malloc(sizeof(char *) * MAX_REDIR);
	result->append_file = malloc(sizeof(char *) * MAX_REDIR);
	if (!result->heredoc_delim || !result->input_file || !result->output_file
		|| !result->append_file)
	{
		free_parsed_cmd(result);
		return (NULL);
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir_syntax.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 13:23:51 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/27 20:54:47 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/minishell.h"

int	count_consecutive_chars(const char *input, int i)
{
	char	c;
	int		count;

	c = input[i];
	count = 1;
	while (input[i + 1] == c)
	{
		count++;
		i++;
	}
	return (count);
}

static int	handle_redir_error(char *input, int i)
{
	ft_putstr_fd("minishell: syntax error near unexpected token `", 2);
	ft_putchar_fd(input[i], 2);
	ft_putstr_fd("'\n", 2);
	return (0);
}

static int	skip_spaces_and_check_end(char *input, int i)
{
	while (input[i] && ft_isspace(input[i]))
		i++;
	if (!input[i] || input[i] == '<' || input[i] == '>')
	{
		return (0);
	}
	return (i);
}

int	check_redir_syntax(char *input)
{
	int	i;
	int	count;

	i = 0;
	while (input[i])
	{
		if (input[i] == '<' || input[i] == '>')
		{
			count = count_consecutive_chars(input, i);
			if (count > 2)
				return (handle_redir_error(input, i));
			i = skip_spaces_and_check_end(input, i + count);
			if (!i)
				return (0);
			i--;
		}
		i++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sep.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/16 15:17:10 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/26 19:45:49 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// fonction qui creer une cellule de la liste chainnee
t_sep	*create_cell(char *cmd_sep)
{
	t_sep	*cell;

	cell = malloc(sizeof(t_sep));
	if (!cell)
		return (NULL);
	cell->prev = NULL;
	cell->next = NULL;
	cell->pipcell = NULL;
	cell->cmd_sep = cmd_sep;
	return (cell);
}

static void	find_insert_position(t_sep **cur, t_sep **prec, int pos)
{
	int	i;

	i = 0;
	while (i < pos && *cur != NULL)
	{
		*prec = *cur;
		*cur = (*cur)->next;
		i++;
	}
}

t_sep	*add_cell(t_sep *list, char *cmd_sep, int pos)
{
	t_sep	*prec;
	t_sep	*cur;
	t_sep	*cell;

	cell = create_cell(cmd_sep);
	if (!list)
		return (cell);
	cur = list;
	prec = NULL;
	find_insert_position(&cur, &prec, pos);
	if (prec)
	{
		prec->next = cell;
		cell->prev = prec;
	}
	if (cur)
	{
		cell->next = cur;
		cur->prev = cell;
	}
	return (list);
}

static int	is_invalid_char(char c)
{
	return (c == '\\' || c == ';');
}

int	check_invalid_chars(const char *cmd)
{
	int		i;
	int		in_quotes;
	char	quote_type;

	if (!cmd)
		return (1);
	i = 0;
	in_quotes = 0;
	quote_type = 0;
	while (cmd[i])	
	{
		if (!in_quotes && (cmd[i] == '\'' || cmd[i] == '"'))
		{
			in_quotes = 1;
			quote_type = cmd[i];
		}
		else if (in_quotes && cmd[i] == quote_type)
			in_quotes = 0;
		else if (!in_quotes && is_invalid_char(cmd[i]))
			return (1);
		i++;
	}
	if (in_quotes)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 11:58:53 by jmaizel           #+#    #+#             */
/*   Updated: 2025/02/27 14:21:25 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"

int g_signal_received = 0;

static void	handle_interactive_signal(int sig)
{
	if (sig == SIGINT)
	{
		g_signal_received = 1;
		ft_putchar_fd('\n', STDERR_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

void	setup_interactive_signals(void)
{
	struct sigaction	sa;

	ft_memset(&sa, 0, sizeof(sa));
	sa.sa_handler = handle_interactive_signal;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa, NULL);
	signal(SIGQUIT, SIG_IGN);
}

char	*get_user_input(void)
{
	char		*input;
	static int	eof_count = 0;

	if (g_signal_received)
	{
		eof_count = 0;
		g_signal_received = 0;
	}
	input = readline("minishell$ ");
	if (!input)
	{
		eof_count++;
		if (eof_count >= 1)
		{
			ft_putstr_fd("exit\n", STDOUT_FILENO);
			return (NULL);
		}
		return (ft_strdup(""));
	}
	eof_count = 0;
	if (input[0] != '\0')
		add_history(input);
	return (input);
}

void	setup_exec_signals(void)
{
	struct sigaction	sa;

	ft_memset(&sa, 0, sizeof(sa));
	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
}

void	restore_signals(void)
{
	setup_interactive_signals();
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/20 11:25:48 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/11 21:42:50 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_str_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

int	ft_isspace(int c)
{
	if (c == 32)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 10:04:22 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/26 08:48:17 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"
#include "../includes/minishell.h"

static char *expand_home_path(char *path)
{
    char *home;

    if (!path || path[0] != '~')
        return (ft_strdup(path));
    home = getenv("HOME");
    if (!home)
        return (ft_strdup(path));
    if (path[1] == '\0')
        return (ft_strdup(home));
    else if (path[1] == '/')
        return (ft_strjoin(home, path + 1));
    return (ft_strdup(path));
}

static int update_env_var(t_tools *tools, const char *name, const char *value)
{
    char *new_var;
    int idx;

    new_var = ft_strjoin_three(name, "=", value);
    if (!new_var)
        return (0);
    idx = find_env_var(tools->env, name);
    if (idx != -1)
    {
        free(tools->env[idx]);
        tools->env[idx] = new_var;
    }
    else
    {
        tools->env = update_env(tools->env, name, value);
        if (!tools->env)
        {
            free(new_var);
            return (0);
        }
    }
    return (1);
}

static void update_pwd_vars(t_tools *tools, const char *old_pwd)
{
    char current_pwd[PATH_MAX];

    if (!getcwd(current_pwd, PATH_MAX))
        return;
    if (old_pwd)
        update_env_var(tools, "OLDPWD", old_pwd);
    update_env_var(tools, "PWD", current_pwd);
}

int builtin_cd(t_tools *tools, char **args)
{
    char *path;
    char *expanded_path = NULL;
    int ret;
    char old_pwd[PATH_MAX];
    int home_idx;

    if (!getcwd(old_pwd, PATH_MAX))
        return (1);
    if (!args[1])
    {
        home_idx = find_env_var(tools->env, "HOME");
        if (home_idx == -1)
            return (ft_printf("minishell: cd: HOME not set\n"), 1);
        path = tools->env[home_idx] + 5; // Passe "HOME=" (5 caractères)
        expanded_path = ft_strdup(path);
    }
    else if (ft_strcmp(args[1], "-") == 0)
    {
        int oldpwd_idx = find_env_var(tools->env, "OLDPWD");
        if (oldpwd_idx == -1)
            return (ft_printf("minishell: cd: OLDPWD not set\n"), 1);
        expanded_path = ft_strdup(tools->env[oldpwd_idx] + 7);
        if (expanded_path)
            ft_printf("%s\n", expanded_path);
    }
    else
        expanded_path = expand_home_path(args[1]);
    if (!expanded_path)
        return (1);
    ret = chdir(expanded_path);
    if (ret == -1)
    {
        ft_printf("minishell: cd: %s: No such file or directory\n", args[1]);
        free(expanded_path);
        return (1);
    }
    update_pwd_vars(tools, old_pwd);
    free(expanded_path);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/12 13:45:41 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/16 20:40:14 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"
#include "../includes/minishell.h"

static int	is_valid_n_option(char *str)
{
	int	i;

	if (!str || str[0] != '-' || str[1] != 'n')
		return (0);
	i = 2;
	while (str[i])
	{
		while (str[i] == 'n')
			i++;
		if (str[i] == 'e')
		{
			while (str[i] == 'e')
				i++;
		}
	}
	return (1);
}

int	builtin_echo(t_tools *tools, char **args)
{
	int	i;
	int	n_flag;

	(void)tools;
	n_flag = 0;
	i = 1;
	while (args[i] && is_valid_n_option(args[i]))
	{
		n_flag = 1;
		i++;
	}
	while (args[i])
	{
		ft_printf("%s", args[i]);
		if (args[i + 1])
			ft_printf(" ");
		i++;
	}
	if (!n_flag)
		ft_printf("\n");
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/09 18:20:19 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 17:43:24 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"
#include "../includes/minishell.h"

int builtin_env(t_tools *tools, char **argv)
{
    int i;

    if (argv[1] != NULL)
    {
        ft_putstr_fd("env: no options or arguments are supported\n", 2);
        return (1);
    }
    i = 0;
    while (tools->env && tools->env[i])
    {
        ft_putendl_fd(tools->env[i], 1);
        i++;
    }
    return (0);
}

void	increment_shell_level(t_tools *tools)
{
	int i = 0;
	int shlvl_index = -1;
	int shlvl_value = 0;
	char *new_value;

	int minishell_exists = 0;
	while (tools->env[i])
	{
		if (ft_strncmp(tools->env[i], "MINISHELL=", 10) == 0)
		{
			minishell_exists = 1;
		}
		if (ft_strncmp(tools->env[i], "SHLVL=", 6) == 0)
		{
			shlvl_index = i;
			shlvl_value = ft_atoi(tools->env[i] + 6);
		}
		i++;
	}
	if (minishell_exists)
	{
		shlvl_value++;
	}
	else
	{
		shlvl_value = 1;
		tools->env = update_env(tools->env, "MINISHELL", "1");
	}

	new_value = ft_itoa(shlvl_value);
	if (shlvl_index != -1)
	{
		free(tools->env[shlvl_index]);
		tools->env[shlvl_index] = ft_strjoin("SHLVL=", new_value);
	}
	else
		tools->env = update_env(tools->env, "SHLVL", new_value);
	free(new_value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/09 18:51:19 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 17:43:39 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/execution.h"

int	count_env_vars(char **env)
{
	int	i;

	i = 0;
	while (env && env[i])
		i++;
	return (i);
}

int	find_env_var(char **env, const char *name)
{
	int		i;
	size_t	len;

	if (!env || !name)
		return (-1);
	len = ft_strlen(name);
	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], name, len) == 0 && env[i][len] == '=')
			return (i);
		i++;
	}
	return (-1);
}

static char *create_env_string(const char *name, const char *value)
{
    char *new_var;
    size_t name_len;
    size_t val_len;
    size_t total_len;

    if (!name)
        return (NULL);
    name_len = ft_strlen(name);
    if (!value)
    {
        new_var = malloc(name_len + 2);
        if (!new_var)
            return (NULL);
        ft_strlcpy(new_var, name, name_len + 1);
        new_var[name_len] = '=';
        new_var[name_len + 1] = '\0';
        return (new_var);
    }
    val_len = ft_strlen(value);
    total_len = name_len + val_len + 2;
    new_var = malloc(total_len);
    if (!new_var)
        return (NULL);
    ft_strlcpy(new_var, name, name_len + 1);
    new_var[name_len] = '=';
    ft_strlcpy(new_var + name_len + 1, value, val_len + 1);
    return (new_var);
}

static char	**replace_env_var(char **env, int index, const char *name, const char *value)
{
	char	*new_var;

	new_var = create_env_string(name, value);
	if (!new_var)
		return (env);
	free(env[index]);
	env[index] = new_var;
	return (env);
}

static char	**append_env_var(char **env, const char *name, const char *value)
{
	char	**new_env;
	char	*new_var;
	int		count;
	int		i;

	count = count_env_vars(env);
	new_env = malloc(sizeof(char *) * (count + 2));
	if (!new_env)
		return (env);
	i = 0;
	while (i < count)
	{
		new_env[i] = env[i];
		i++;
	}
	new_var = create_env_string(name, value);
	if (!new_var)
	{
		free(new_env);
		return (env);
	}
	new_env[count] = new_var;
	new_env[count + 1] = NULL;
	free(env);
	return (new_env);
}

char	**update_env(char **env, const char *name, const char *value)
{
	int	index;

	if (!env || !name)
		return (env);
	index = find_env_var(env, name);
	if (index >= 0)
		return (replace_env_var(env, index, name, value));
	return (append_env_var(env, name, value));
}

char	*get_env_name(const char *var)
{
	char	*eq_pos;

	if (!var)
		return (NULL);
	eq_pos = ft_strchr(var, '=');
	if (!eq_pos)
		return (ft_strdup(var));
	return (ft_substr(var, 0, eq_pos - var));
}

char	*get_env_value(const char *var)
{
	char	*eq_pos;

	if (!var)
		return (NULL);
	eq_pos = ft_strchr(var, '=');
	if (!eq_pos)
		return (NULL);
	return (ft_strdup(eq_pos + 1));
}

char	*ft_strjoin_three(const char *s1, const char *s2, const char *s3)
{
	char	*tmp;
	char	*result;

	tmp = ft_strjoin(s1, s2);
	if (!tmp)
		return (NULL);
	result = ft_strjoin(tmp, s3);
	free(tmp);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/11 21:12:12 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/25 19:53:07 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"

static int is_numeric(const char *str)
{
    int i;

    if (!str || !str[0])
        return (0);
    i = 0;
    if (str[i] == '+' || str[i] == '-')
        i++;
    while (str[i])
    {
        if (!ft_isdigit(str[i]))
            return (0);
        i++;
    }
    return (1);
}

int builtin_exit(t_tools *tools, char **argv)
{
    int exit_status;

    ft_putendl_fd("exit", 1);
    if (argv[1])
    {
        if (!is_numeric(argv[1]))
        {
            ft_putstr_fd("exit: ", 2);
            ft_putstr_fd(argv[1], 2);
            ft_putendl_fd(": numeric argument required", 2);
            exit_status = 2;
        }
        else
        {
            exit_status = ft_atoi(argv[1]);
            if (argv[2])
            {
                ft_putendl_fd("exit: too many arguments", 2);
                return (1);
            }
        }
    }
    else
        exit_status = tools->exit_code;
    cleanup_minishell(tools);
    exit(exit_status);
    return (exit_status); // Inatteignable, mais pour la forme
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/09 01:30:47 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 17:43:13 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/minishell.h"
#include "../../includes/builtins.h"

static int is_valid_identifier(const char *str)
{
    int i;
    if (!str || !*str || ft_isdigit(*str))
        return (0);
    i = 0;
    while (str[i] && str[i] != '=')
    {
        if (!ft_isalnum(str[i]) && str[i] != '_')
            return (0);
        i++;
    }
    return (1); // Accepte "VAR=" comme valide
}

static void print_sorted_env(char **env)
{
    int i;
    int j;
    char **sorted;
    char *tmp;
    int count;

    count = count_env_vars(env);
    sorted = malloc(sizeof(char *) * (count + 1));
    if (!sorted)
        return ;
    i = -1;
    while (env[++i])
        sorted[i] = ft_strdup(env[i]);
    sorted[i] = NULL;
    i = -1;
    while (sorted[++i] && sorted[i + 1])
    {
        j = i;
        while (sorted[++j])
        {
            if (ft_strcmp(sorted[i], sorted[j]) > 0)
            {
                tmp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = tmp;
            }
        }
    }
    i = -1;
    while (sorted[++i])
    {
        ft_printf("declare -x %s\n", sorted[i]);
        free(sorted[i]);
    }
    free(sorted);
}

int builtin_export(t_tools *tools, char **argv)
{
    int i;
    char *name;
    char *value;
    int ret;

    ret = 0;
    if (!argv[1])
    {
        print_sorted_env(tools->env);
        return (0);
    }
    i = 1;
    while (argv[i])
    {
        name = get_env_name(argv[i]);
        if (!name || !is_valid_identifier(name))
        {
            ft_printf("minishell: export: '%s': not a valid identifier\n", argv[i]);
            free(name);
            ret = 1;
            i++;
            continue;
        }
        value = get_env_value(argv[i]);
        char **new_env = update_env(tools->env, name, value ? value : "");
        tools->env = new_env;
        free(name);
        free(value);
        i++;
    }
    return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jacobmaizel <jacobmaizel@student.42.fr>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/12 13:59:46 by jacobmaizel       #+#    #+#             */
/*   Updated: 2025/02/12 14:09:13 by jacobmaizel      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"
#include "../includes/minishell.h"

// fonction pour gerer pwd :
// 1. PATH_MAX est une constante systeme qui definit la longueur maximale
// d un chemin (generalement 4096)
// 2. getcwd est une fonction systeme qui stock le chemin et renvoie NULL en
// cas d erreur
// 3.strerror(errno) converti le code d erreur en message
int	builtin_pwd(t_tools *tools, char **args)
{
	char	current_pwd[PATH_MAX];

	(void)args;
	(void)tools;
	if (!getcwd(current_pwd, PATH_MAX))
	{
		ft_printf("pwd: %s\n", strerror(errno));
		return (1);
	}
	ft_printf("%s\n", current_pwd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 20:18:28 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/10 20:31:46 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/builtins.h"

static int	is_invalid_identifier(const char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (1);
	i = 1;
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (1);
		i++;
	}
	return (0);
}

static void	remove_env_var(char **env, int index)
{
	free(env[index]);
	while (env[index + 1])
	{
		env[index] = env[index + 1];
		index++;
	}
	env[index] = NULL;
}

int	builtin_unset(t_tools *tools, char **argv)
{
	int		i;
	int		env_idx;

	i = 1;
	while (argv[i])
	{
		if (is_invalid_identifier(argv[i]))
		{
			ft_putstr_fd("minishell: unset: `", 2);
			ft_putstr_fd(argv[i], 2);
			ft_putstr_fd("': not a valid identifier\n", 2);
		}
		else
		{
			env_idx = find_env_var(tools->env, argv[i]);
			if (env_idx >= 0)
				remove_env_var(tools->env, env_idx);
		}
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/08 17:44:53 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 11:49:38 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/builtins.h"
#include "../../includes/execution.h"
#include "../../includes/minishell.h"

int			g_signal_recieved = 0;

static void	init_minishell(t_tools *tools, char **env)
{
	int	i;
	int	j;

	ft_memset(tools, 0, sizeof(t_tools));
	i = 0;
	while (env[i])
		i++;
	tools->env = malloc(sizeof(char *) * (i + 1));
	if (!tools->env)
		return ;
	j = 0;
	while (j < i)
	{
		tools->env[j] = ft_strdup(env[j]);
		if (!tools->env[j])
		{
			while (--j >= 0)
				free(tools->env[j]);
			free(tools->env);
			tools->env = NULL;
			return ;
		}
		j++;
	}
	tools->env[i] = NULL;
	tools->exit_code = 0;
	tools->tokens = NULL;
	tools->cmds = NULL;
}

void	cleanup_minishell(t_tools *tools)
{
	int	i;

	if (tools->env)
	{
		i = 0;
		while (tools->env[i])
		{
			free(tools->env[i]);
			i++;
		}
		free(tools->env);
		tools->env = NULL;
	}
	rl_clear_history();
}

static int	handle_execution(t_tools *tools, char *user_input)
{
	t_sep	*cell;

	if (!user_input || check_invalid_chars(user_input))
	{
		ft_printf("Error: Invalid input\n");
		return (1);
	}
	cell = create_cell(ft_strdup(user_input));
	if (!cell)
		return (1);
	parse_pipes(cell);
	if (cell && cell->pipcell)
	{
		setup_exec_signals();
		parsing_line(user_input, tools);
		exec_commands(cell, tools);
		restore_signals();
	}
	free_cell(cell);
	return (0);
}

int	main(int argc, char **argv, char **env)
{
	t_tools	tools;
	char	*user_input;

	(void)argc;
	(void)argv;
	init_minishell(&tools, env);
	increment_shell_level(&tools);
	setup_interactive_signals();
	while (1)
	{
		g_signal_received = 0;
		user_input = get_user_input();
		if (!user_input || !ft_strncmp(user_input, "exit", 5))
		{
			if (user_input)
				free(user_input);
			break ;
		}
		if (user_input[0] != '\0')
			handle_execution(&tools, user_input);
		free(user_input);
	}
	cleanup_minishell(&tools);
	return (tools.exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/09 15:26:11 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 11:40:24 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILTINS_H
# define BUILTINS_H

# include "minishell.h"

//#define PATH_MAX 4096

/* Builtins */
int		builtin_env(t_tools *tools, char **argv);
int		builtin_export(t_tools *tools, char **argv);
int		builtin_unset(t_tools *tools, char **argv);
int		builtin_exit(t_tools *tools, char **argv);
int		builtin_env(t_tools *tools, char **argv);
int		builtin_cd(t_tools *tools, char **args);
int		builtin_echo(t_tools *tools, char **args);
int		builtin_pwd(t_tools *tools, char **args);

/* Environment utilities */
int		find_env_var(char **env, const char *name);
char	**update_env(char **env, const char *name, const char *value);
char	*get_env_name(const char *var);
char	*get_env_value(const char *var);
int		count_env_vars(char **env);
char	*ft_strjoin_three(const char *s1, const char *s2, const char *s3);
void	increment_shell_level(t_tools *tools);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execution.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/08 17:42:22 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/27 16:04:04 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef EXECUTION_H
# define EXECUTION_H

# include "minishell.h"
# include <signal.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <fcntl.h>
# include <termios.h>

# define PIPE_READ 0
# define PIPE_WRITE 1

typedef struct s_process
{
	pid_t	pid;
	int		pipe_fd[2];
	int		stdin_backup;
	int		stdout_backup;
}	t_process;

typedef struct s_exec
{
	t_tools		*tools;
	t_process	process;
	int			exit_status;
	int			pipe_count;
	char		**cmd_paths;
}	t_exec;

/* exec.c */
void	init_exec_struct(t_exec *exec, t_tools *tools);
int		exec_commands(t_sep *cell, t_tools *tools);

/* exec_cmd.c */
int		exec_simple_cmd(t_pip *cmd, t_exec *exec);

/* exec_pipe.c */
int		exec_pipeline(t_pip *pipeline, t_exec *exec, int heredoc_fd);

/* exec_redir.c */
int     setup_redirections(t_parsed_cmd *cmd, t_process *process, t_exec *exec);
void	restore_redirections(t_process *process);

/* exec_heredoc.c */
void	setup_heredoc_signals(void);
int		handle_heredoc(t_parsed_cmd *cmd, t_exec *exec);

/* exec_signals.c */
void	setup_parent_signals(void);
void	setup_child_signals(void);

/* exec_utils.c */
int		count_pipes(t_pip *pipeline);
void	close_pipe(int pipe_fd[2]);
void	wait_all_processes(t_exec *exec, int process_count);

/* exec_path.c */
char	*get_cmd_path(char *cmd, char **cmd_paths);

/* exec_builtins.c */
int		is_builtin(char *cmd);
int		handle_builtin(t_pip *cmd, t_exec *exec);
int		execute_builtin(t_cmd_args *args, t_exec *exec);

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 12:08:50 by cdedessu          #+#    #+#             */
/*   Updated: 2025/02/26 19:34:06 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H
# include "../libft/includes/ft_printf.h"
# include "../libft/includes/libft.h"
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <limits.h>
# include <stdio.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stdlib.h>
# include <string.h>
# include <sys/wait.h>
# include <unistd.h>

extern int					g_signal_received;

typedef struct s_tools
{
	char					**env;
	int						exit_code;
	struct s_simple_cmds	*cmds;
	struct s_tokens			*tokens;
}							t_tools;

typedef struct s_sep
{
	char					*cmd_sep;
	struct s_sep			*prev;
	struct s_sep			*next;
	struct s_pip			*pipcell;
}							t_sep;

typedef struct s_cmd_args
{
	char					**argv;
	int						argc;
	char					*cmd;
}							t_cmd_args;

typedef struct s_parsed_cmd
{
	char					*full_cmd;
	char					*cmd;
	char					**input_file;
	int						input_count;
	char					**output_file;
	int						output_count;
	char					**append_file;
	int						append_count;
	char					**heredoc_delim;
	int						heredoc_count;
}							t_parsed_cmd;

typedef struct s_pip
{
	char					*cmd_pipe;
	t_parsed_cmd			*redirection;
	struct s_pip			*next;
	struct s_pip			*prev;
	int						pip_count;
}							t_pip;

typedef struct s_expand
{
	size_t					i;
	size_t					j;
	int						in_quotes;
	size_t					size;
}							t_expand;

/*
** Environment functions (env.c)
*/
void						print_env_vars(t_tools *tools);
char						**get_env_paths(char **env, char *var_name);

/*
** Command argument functions (cmd_args_parse.c, cmd_args_utils.c)
*/
t_cmd_args					*parse_command_args(char *cmd_str);
void						print_cmd_args(t_cmd_args *cmd_args);
void						free_cmd_args(t_cmd_args *cmd_args);

/*
** Argument counting functions (count_args.c)
*/
int							count_args(char *str);

/*
** Redirections functions (redir_syntax.c, redir_init.c, redir_file.c,
	parse_redir.c)
*/
int							count_consecutive_chars(const char *input, int i);
int							check_redir_syntax(char *input);
t_parsed_cmd				*init_parsed_cmd(void);
char						*find_file_end(char *ptr);
void						handle_redirection(char **ptr, t_parsed_cmd *result,
								int type);

/*
** Parsed command functions (parse_display.c, parse_cleanup.c)
*/
void						print_parsed_command(t_parsed_cmd *cmd);
void						free_parsed_cmd(t_parsed_cmd *cmd);
void						parsing_line(char *user_input, t_tools *tools);
int							extract_arg(char **args, char *cmd_str, int i,
								int *j);
t_parsed_cmd				*parse_redir(char *input);
/*
** Cell functions (sep.c, parse_cleanup.c)
*/
t_sep						*create_cell(char *cmd_sep);
t_sep						*add_cell(t_sep *list, char *cmd_sep, int pos);
void						free_cell(t_sep *cell);
int							check_invalid_chars(const char *cmd);

/*
** Pipe functions (parsing_pipe.c, print_pipe_command.c)
*/
void						parse_pipes(t_sep *cell);
void						print_pipe_command(t_pip *pipe_cmd, int pipe_num);

/*
** Quote handling functions (quotes.c)
*/
char						*clean_quotes(char *str);

/*
** Signal functions (signals.c)
*/
void						setup_interactive_signals(void);
void						setup_exec_signals(void);
void						restore_signals(void);
char						*get_user_input(void);

/*
** Utility functions (utils.c)
*/
void						free_str_array(char **array);
int							ft_isspace(int c);

/*
** Prompt function (prompt.c)
*/
void						loop_prompt(t_tools *tools, char **env);

/*
** Expansion functions (expansion_core.c, expansion_utils.c,
	expansion_variables.c)
*/
char						*expand_str(const char *str, t_tools *tools);
char						*resize_buffer(char *result, size_t *size,
								size_t needed_size);
char						*get_var_value(const char *var_name, char **env);
char						*handle_variable(const char *str, size_t *i,
								t_tools *tools);
/*
** process
*/
void						process_redirection(char **ptr,
								t_parsed_cmd *result, char **cmd_ptr);
void	process_quotes(char **cmd_ptr, char **ptr, int *in_quotes,
		char *quote_type);

/*
** main
*/
void						cleanup_minishell(t_tools *tools);
#endif