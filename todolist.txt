- Avant le parsing
Récupérer les variables d'environnement :

(FAIT)
Écrire une fonction pour stocker toutes les variables d'environnement (char **env) dans une structure dédiée dans t_tools.
Exemple : t_tools.env = env;

(FAIT)
Écrire une fonction pour récupérer une variable spécifique (exemple : PATH) dans un tableau de chemins avec ft_split.
À faire :

(FAIT)
Récupérer la valeur de PATH depuis env.
Splitter le contenu de PATH par : pour obtenir les chemins dans un char **.
Fonction utile :

c
Copier
Modifier
char **get_paths_from_env(char **env);
Créer le prompt :

Utiliser get_next_line pour lire en boucle les entrées utilisateur.
Afficher le prompt avant chaque commande (write(1, "~$ ", 3)).
Stocker la commande dans une variable pour l'étape de parsing.
Fonction utile :

c
Copier
Modifier
char *get_user_input(void);



- Parsing

1. Gestion des séparateurs ;
Séparer les commandes par ; dans un char ** avec ft_split.

Exemple : input = "echo Hello; echo World" → str[0] = "echo Hello", str[1] = "echo World"
Stocker chaque commande séparée dans une liste chaînée (t_sep ou similaire).

Créer une cellule pour chaque commande avec :
Le contenu de la commande (cmd_sep).
Les pointeurs prev et next.
Fonctions à écrire :

Création d'une cellule (create_cell).
Ajout d'une cellule dans la liste (add_cell).
Affichage des cellules pour debug (print_list).


2. Gestion des pipes |
Parcourir la liste des commandes (t_sep) :

Si une commande contient un pipe (|), splitter cette commande en plusieurs parties avec ft_split par |.
Créer une sous-liste chaînée (list->pipcell) :

Ajouter chaque commande entre pipes dans une cellule séparée (t_pipe ou similaire).
Exemple : ls | sort | wc → pipcell[0] = "ls", pipcell[1] = "sort", pipcell[2] = "wc".
Fonctions à écrire :

Gestion des pipes dans une commande (parse_pipes).
Création de la sous-liste des pipes (add_pipe_cell).


3. Gestion des commandes et arguments
Parser chaque commande en arguments :

Séparer les mots par espace tout en respectant les règles de parsing (quotes, échappement, etc.).
Créer un tableau argv prêt pour l'exécution.
Exemple : echo -n bonjour → argv[0] = "echo", argv[1] = "-n", argv[2] = "bonjour", argv[3] = NULL.
Fonctions à écrire :

Création du tableau d'arguments (parse_arguments).
Gestion des quotes (handle_quotes).
Gestion des caractères d’échappement (handle_escape_characters).



4. Gestion des protections
Quotes simples et doubles :

Implémenter la gestion des quotes simples (') et doubles (").
Protéger les variables d'environnement, caractères spéciaux, et autres cas dans les quotes.
Caractères d'échappement :

Implémenter la gestion des caractères précédés d’un \ :
Exemple : \$ ne remplace pas la variable d'environnement.
\n doit être interprété comme n.
Fonctions à écrire :

Vérification des quotes équilibrées (check_quotes_balance).
Expansion des variables d'environnement (expand_env_variables).


- Résumé des étapes clés
Récupérer les variables d’environnement :
Stocker PATH et autres variables nécessaires dans une structure.
Lire la commande utilisateur :
Afficher le prompt et récupérer l’entrée utilisateur.
Séparer par ; et créer une liste chaînée :
Utiliser ft_split pour découper les commandes.
Gérer les cellules dans une liste.
Gérer les pipes :
Identifier les pipes et créer des sous-listes pour les commandes.
Parser les commandes et arguments :
Créer le tableau argv en respectant les quotes, échappements, et variables.
Protéger les entrées :
Implémenter la gestion des quotes et des caractères d’échappement.
V - Conseils pratiques
Progresser par étapes :
Implémenter chaque partie (par exemple, les séparations ;) avant de passer aux suivantes.
Déboguer chaque étape :
Afficher les structures créées (ex. : listes chaînées, sous-listes) pour vérifier leur contenu.
Documenter ton code :
Ajouter des commentaires clairs pour expliquer chaque partie.

