#include "../includes/builtins.h"

static char	*get_env_value(char **env, const char *var_name)
{
	int	i;
	int	len;

	if (!env || !var_name)
		return (NULL);
	len = ft_strlen(var_name);
	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], var_name, len) == 0 && env[i][len] == '=')
			return (env[i] + len + 1);
		i++;
	}
	return (NULL);
}

static int	update_pwd_env(t_env_manager *env_mgr)
{
	char	current_pwd[PATH_MAX];
	char	*old_pwd;
	int		i;

	if (!getcwd(current_pwd, sizeof(current_pwd)))
		return (ERR_GETCWD_FAILED);
	old_pwd = get_env_value(env_mgr->tools->env, "PWD");
	i = 0;
	while (env_mgr->tools->env[i])
	{
		if (ft_strncmp(env_mgr->tools->env[i], "PWD=", 4) == 0)
		{
			free(env_mgr->tools->env[i]);
			env_mgr->tools->env[i] = ft_strjoin("PWD=", current_pwd);
		}
		else if (ft_strncmp(env_mgr->tools->env[i], "OLDPWD=", 7) == 0)
		{
			free(env_mgr->tools->env[i]);
			env_mgr->tools->env[i] = ft_strjoin("OLDPWD=", old_pwd ? old_pwd : "");
		}
		i++;
	}
	return (SUCCESS);
}

int	builtin_cd(t_parsed_cmd *cmd, t_tools *tools, t_env_manager *env_mgr)
{
	char	*target_dir;
	char	**args;

	args = ft_split(cmd->full_cmd, ' ');
	if (!args)
		return (ERR_MALLOC_FAILURE);
	if (!args[1])
	{
		target_dir = get_env_value(env_mgr->tools->env, "HOME");
		if (!target_dir)
		{
			free_str_array(args);
			return (ERR_GETCWD_FAILED);
		}
	}
	else if (ft_strcmp(args[1], "-") == 0)
	{
		target_dir = get_env_value(env_mgr->tools->env, "OLDPWD");
		if (!target_dir)
		{
			free_str_array(args);
			return (ERR_GETCWD_FAILED);
		}
		ft_printf("%s\n", target_dir);
	}
	else
		target_dir = args[1];
	if (chdir(target_dir) != 0)
	{
		ft_printf("minishell: cd: %s: No such file or directory\n", target_dir);
		free_str_array(args);
		return (ERR_CHDIR_FAILED);
	}
	update_pwd_env(env_mgr);
	free_str_array(args);
	return (SUCCESS);
}