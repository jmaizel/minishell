/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 11:03:16 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 13:46:55 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

void	free_str_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		array[i] = NULL;
		i++;
	}
	free(array);
}

void	cleanup_parsed_cmd(t_parsed_cmd *cmd)
{
	if (!cmd)
		return ;
	if (cmd->full_cmd)
	{
		free(cmd->full_cmd);
		cmd->full_cmd = NULL;
	}
	if (cmd->cmd)
	{
		free(cmd->cmd);
		cmd->cmd = NULL;
	}
	free_str_array(cmd->input_file);
	free_str_array(cmd->output_file);
	free_str_array(cmd->append_file);
	free_str_array(cmd->heredoc_delim);
	free(cmd);
}

void	cleanup_pip(t_pip *pip)
{
	t_pip	*current;
	t_pip	*next;

	current = pip;
	while (current)
	{
		next = current->next;
		if (current->cmd_pipe)
		{
			free(current->cmd_pipe);
			current->cmd_pipe = NULL;
		}
		if (current->redirection)
			cleanup_parsed_cmd(current->redirection);
		free(current);
		current = next;
	}
}

void	cleanup_cmd_args(t_cmd_args *args)
{
	if (!args)
		return ;
	if (args->argv)
	{
		free_str_array(args->argv);
		args->argv = NULL;
	}
	if (args->cmd)
	{
		free(args->cmd);
		args->cmd = NULL;
	}
	free(args);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 11:43:19 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/29 14:22:32 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

char	*get_env_var(const char *key, char **env)
{
	int	len;
	int	i;

	if (!key || !env)
		return (NULL);
	len = ft_strlen(key);
	i = 0;
	while (env[i])
	{
		if (ft_strncmp(env[i], key, len) == 0 && env[i][len] == '=')
			return (env[i] + len + 1);
		i++;
	}
	return (NULL);
}

int	add_env_var(char *var, char ***env)
{
	int			i;
	char		**new_env;

	if (!var || !env || !*env)
		return (ERR_INVALID_CMD);
	i = 0;
	while ((*env)[i])
	{
		if (ft_strncmp((*env)[i], var, ft_strchr(var, '=') - var) == 0)
		{
			free((*env)[i]);
			(*env)[i] = ft_strdup(var);
			if (!(*env)[i])
				return (ERR_MALLOC_FAILURE);
			return (SUCCESS);
		}
		i++;
	}
	new_env = malloc(sizeof(char *) * (i + 2));
	if (!new_env)
		return (ERR_MALLOC_FAILURE);
	ft_memcpy(new_env, *env, sizeof(char *) * i);
	new_env[i] = ft_strdup(var);
	if (!new_env[i])
	{
		free(new_env);
		return (ERR_MALLOC_FAILURE);
	}
	new_env[i + 1] = NULL;
	free(*env);
	*env = new_env;
	return (SUCCESS);
}

int	remove_env_var(char *key, char ***env)
{
	int	len;
	int	i;

	len = ft_strlen(key);
	i = 0;
	while ((*env)[i])
	{
		if (ft_strncmp((*env)[i], key, len) == 0 && (*env)[i][len] == '=')
		{
			free((*env)[i]);
			while ((*env)[i])
			{
				(*env)[i] = (*env)[i + 1];
				i++;
			}
			return (0);
		}
		i++;
	}
	return (1);
}

char	**duplicate_env(char **env)
{
	int			i;
	char		**new_env;

	i = 0;
	while (env[i])
		i++;
	new_env = malloc(sizeof(char *) * (i + 1));
	if (!new_env)
		return (NULL);
	i = 0;
	while (env[i])
	{
		new_env[i] = ft_strdup(env[i]);
		if (!new_env[i])
		{
			while (--i >= 0)
				free(new_env[i]);
			free(new_env);
			return (NULL);
		}
		i++;
	}
	new_env[i] = NULL;
	return (new_env);
}

void	free_env(char **env)
{
	int	i;

	if (!env)
		return ;
	i = 0;
	while (env[i])
	{
		free(env[i]);
		i++;
	}
	free(env);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   error_handling.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/27 10:49:47 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/28 13:49:17 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

void	handle_error(const char *msg)
{
	perror(msg);
	exit(ERROR_EXIT);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execution.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 10:17:29 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 14:43:56 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"


static int is_builtin(const char *cmd)
{
    return (cmd && (ft_strcmp(cmd, "echo") == 0
        || ft_strcmp(cmd, "cd") == 0
        || ft_strcmp(cmd, "pwd") == 0
        || ft_strcmp(cmd, "env") == 0
        || ft_strcmp(cmd, "export") == 0
        || ft_strcmp(cmd, "unset") == 0
        || ft_strcmp(cmd, "exit") == 0));
}

static int execute_builtin(t_parsed_cmd *cmd, t_tools *tools)
{
    int ret;
    char *cmd_name;

    if (!cmd || !cmd->cmd)
        return (0);

    cmd_name = cmd->cmd;

    if (ft_strcmp(cmd_name, "echo") == 0)
        ret = builtin_echo(cmd);
    else if (ft_strcmp(cmd_name, "cd") == 0)
        ret = builtin_cd(cmd, tools);
    else if (ft_strcmp(cmd_name, "pwd") == 0)
        ret = builtin_pwd(cmd, tools);
    else if (ft_strcmp(cmd_name, "env") == 0)
        ret = builtin_env(cmd, tools);
    else if (ft_strcmp(cmd_name, "export") == 0)
        ret = builtin_export(cmd, tools);
    else if (ft_strcmp(cmd_name, "unset") == 0)
        ret = builtin_unset(cmd, tools);
    else if (ft_strcmp(cmd_name, "exit") == 0)
        ret = builtin_exit(cmd, tools);
    else
        return (0);

    tools->exit_code = ret;
    return (1);
}

void execute_external_command(t_pip *pip, t_tools *tools)
{
    char *path;
    pid_t pid;
    int status;
    t_parsed_cmd *cmd;
    t_cmd_args *args;

    if (!pip || !pip->redirection || !tools)
    {
        ft_putstr_fd("Error: invalid command structure.\n", STDERR_FILENO);
        tools->exit_code = ERR_INVALID_CMD;
        return;
    }

    cmd = pip->redirection;
    if (!cmd || !cmd->cmd)
    {
        ft_putstr_fd("Error: invalid command structure.\n", STDERR_FILENO);
        tools->exit_code = ERR_INVALID_CMD;
        return;
    }

    path = find_executable(cmd->cmd, tools->env);
    if (!path)
    {
        ft_putstr_fd("Command not found: ", STDERR_FILENO);
        ft_putendl_fd(cmd->cmd, STDERR_FILENO);
        tools->exit_code = CMD_NOT_FOUND;
        return;
    }

    args = parse_command_args(cmd->full_cmd);
    if (!args)
    {
        free(path);
        tools->exit_code = ERR_MALLOC_FAILURE;
        return;
    }

    pid = fork();
    if (pid == 0)
    {
        apply_redirections(pip);
        if (execve(path, args->argv, tools->env) == -1)
        {
            perror("execve failed");
            free_cmd_args(args);
            free(path);
            exit(ERR_EXEC_FAILURE);
        }
    }
    else if (pid > 0)
    {
        waitpid(pid, &status, 0);
        tools->exit_code = WEXITSTATUS(status);
    }
    else
        perror("fork failed");

    free_cmd_args(args);
    free(path);
}

void execute_simple_command(t_pip *pip, t_tools *tools)
{
    t_parsed_cmd *cmd;

    if (!pip || !pip->redirection || !tools)
    {
        ft_putstr_fd("Error: invalid command structure.\n", STDERR_FILENO);
        return;
    }

    cmd = pip->redirection;
    if (!cmd->cmd)
    {
        ft_putstr_fd("Error: empty command.\n", STDERR_FILENO);
        return;
    }

    if (is_builtin(cmd->cmd))
        execute_builtin(cmd, tools);
    else
        execute_external_command(pip, tools);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execution_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 11:41:52 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/27 20:10:52 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

static void	ft_free_split(char **split)
{
	int	i;

	if (!split)
		return ;
	i = 0;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

static char	*check_access(char *path, char *command)
{
	char	*full_path;
	char	*temp;

	full_path = ft_strjoin(path, "/");
	if (!full_path)
		return (NULL);
	temp = ft_strjoin(full_path, command);
	free(full_path);
	full_path = temp;
	if (!full_path)
		return (NULL);
	if (access(full_path, X_OK) == 0)
		return (full_path);
	free(full_path);
	return (NULL);
}

char	*find_executable(char *command, char **env)
{
	char	**paths;
	char	*path;
	char	*full_path;
	int		i;

	if (!command || !env)
		return (NULL);
	path = get_env_var("PATH", env);
	if (!path || !*path)
	{
		ft_putstr_fd("Error: PATH not found in environment.\n", STDERR_FILENO);
		return (NULL);
	}
	paths = ft_split(path, ':');
	if (!paths)
		return (NULL);
	i = 0;
	while (paths[i])
	{
		full_path = check_access(paths[i], command);
		if (full_path)
		{
			ft_free_split(paths);
			return (full_path);
		}
		i++;
	}
	ft_free_split(paths);
	return (NULL);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_status.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 11:07:36 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 13:30:10 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

void	update_exit_status(t_tools *tools, int status)
{
	if (WIFEXITED(status))
		tools->exit_code = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
	{
		tools->exit_code = 128 + WTERMSIG(status);
		if (WTERMSIG(status) == SIGQUIT)
			ft_putendl_fd("Quit (core dumped)", STDERR_FILENO);
	}
}

int	get_command_exit_status(t_pip *pip)
{
	t_cmd_args	*args;
	int			exit_status;

	if (!pip || !pip->redirection || !pip->redirection->cmd)
		return (GENERAL_ERROR);

	args = parse_command_args(pip->redirection->full_cmd);
	if (!args || !args->argv || !args->argv[0])
	{
		free_cmd_args(args);
		return (GENERAL_ERROR);
	}

	if (ft_strcmp(args->argv[0], "exit") == 0)
	{
		if (args->argv[1])
			exit_status = ft_atoi(args->argv[1]);
		else
			exit_status = 0;
		free_cmd_args(args);
		return (exit_status);
	}
	free_cmd_args(args);
	return (GENERAL_ERROR);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expansion.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 10:44:03 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/27 16:46:42 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

static char	*get_variable_name(char *str)
{
	int		i;
	char	*name;

	i = 0;
	while (str[i] && (ft_isalnum(str[i]) || str[i] == '_'))
		i++;
	name = ft_substr(str, 0, i);
	if (!name)
		return (NULL);
	return (name);
}

static char	*expand_exit_status(t_tools *tools)
{
	return (ft_itoa(tools->exit_code));
}

static char	*handle_variable_expansion(char *str, t_tools *tools)
{
	char	*var_name;
	char	*value;

	if (str[0] == '?')
		return (expand_exit_status(tools));
	var_name = get_variable_name(str);
	if (!var_name)
		return (ft_strdup(""));
	value = get_env_var(var_name, tools->env);
	free(var_name);
	if (value)
		return (ft_strdup(value));
	return (ft_strdup(""));
}

static char	*append_variable(char *result, char *str, int *i, t_tools *tools)
{
	char	*var_value;
	char	*temp;

	(*i)++;
	var_value = handle_variable_expansion(str + *i, tools);
	temp = ft_strjoin(result, var_value);
	free(var_value);
	free(result);
	while (str[*i] && (ft_isalnum(str[*i]) || str[*i] == '_'))
		(*i)++;
	return (temp);
}

static char	*append_character(char *result, char c)
{
	char	*temp;

	temp = ft_charjoin(result, c);
	free(result);
	return (temp);
}

char	*expand_variables(char *str, t_tools *tools)
{
	char	*result;
	bool	in_single_quotes;
	bool	in_double_quotes;
	int		i;

	if (!str)
		return (NULL);
	result = ft_strdup("");
	if (!result)
		return (NULL);
	in_single_quotes = false;
	in_double_quotes = false;
	i = 0;
	while (str[i])
	{
		if (str[i] == '\'' && !in_double_quotes)
			in_single_quotes = !in_single_quotes;
		else if (str[i] == '"' && !in_single_quotes)
			in_double_quotes = !in_double_quotes;
		else if (str[i] == '$' && !in_single_quotes && str[i + 1])
			result = append_variable(result, str, &i, tools);
		else
			result = append_character(result, str[i]);
		i++;
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/28 10:00:00 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 13:47:43 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

static void	heredoc_sigint_handler(int sig)
{
	(void)sig;
	write(STDERR_FILENO, "\n", 1);
	exit(130);
}

static void	handle_heredoc_signals(void)
{
	signal(SIGINT, heredoc_sigint_handler);
	signal(SIGQUIT, SIG_IGN);
}

static char	*create_heredoc_filename(void)
{
	static int	counter = 0;
	char		*pid_str;
	char		*count_str;
	char		*temp;
	char		*filename;

	pid_str = ft_itoa(getpid());
	count_str = ft_itoa(counter++);
	if (!pid_str || !count_str)
	{
		free(pid_str);
		free(count_str);
		return (NULL);
	}
	temp = ft_strjoin("/tmp/.heredoc_", pid_str);
	free(pid_str);
	if (!temp)
	{
		free(count_str);
		return (NULL);
	}
	filename = ft_strjoin(temp, count_str);
	free(temp);
	free(count_str);
	return (filename);
}

static int	write_heredoc_content(int fd, char *delimiter)
{
	char	*line;

	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			return (0);
		}
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
	return (1);
}

void	handle_heredoc(char *delim, t_pip *pip)
{
	char	*filename;
	int		fd;
	pid_t	pid;
	int		status;

	filename = create_heredoc_filename();
	if (!filename)
		handle_error("heredoc: filename creation failed");
	
	pid = fork();
	if (pid == 0)
	{
		handle_heredoc_signals();
		fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0600);
		if (fd == -1)
			handle_error("heredoc: open failed");
		if (write_heredoc_content(fd, delim))
			exit(130);
		close(fd);
		exit(0);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status) && WEXITSTATUS(status) == 130)
	{
		unlink(filename);
		free(filename);
		exit(130);
	}
	
	fd = open(filename, O_RDONLY);
	if (fd == -1)
		handle_error("heredoc: open failed");
	
	if (pip && pip->redirection)
	{
		if (dup2(fd, STDIN_FILENO) == -1)
			handle_error("heredoc: dup2 failed");
	}
	close(fd);
	unlink(filename);
	free(filename);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 17:41:59 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 12:46:37 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

int count_pipes(t_pip *cmd)
{
    int count = 0;
    while (cmd)
    {
        if (cmd->next)
            count++;
        cmd = cmd->next;
    }
    return (count);
}

void cleanup_pipe_array(int **pipes, int count)
{
    int i;
    if (!pipes || !*pipes)
        return;
    i = 0;
    while (i < count)
    {
        close((*pipes)[i * 2]);
        close((*pipes)[i * 2 + 1]);
        i++;
    }
    free(*pipes);
    *pipes = NULL;
}

int *create_pipes(int count)
{
    int *pipes;
    int i;

    pipes = malloc(sizeof(int) * 2 * count);
    if (!pipes)
        return (NULL);
    i = 0;
    while (i < count)
    {
        if (pipe(pipes + (i * 2)) == -1)
        {
            perror("pipe failed");
            cleanup_pipe_array(&pipes, i);
            return (NULL);
        }
        i++;
    }
    return (pipes);
}

void close_all_pipes(int *pipes, int pipe_count)
{
    int i;

    i = 0;
    while (i < pipe_count * 2)
    {
        close(pipes[i]);
        i++;
    }
    free(pipes);
}

pid_t *allocate_pids(int count)
{
    pid_t *pids;

    pids = malloc(sizeof(pid_t) * count);
    if (!pids)
    {
        perror("malloc failed for pids");
        return (NULL);
    }
    return (pids);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 11:37:38 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 12:01:27 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

int count_pipes(t_pip *cmd)
{
    int count = 0;
    while (cmd)
    {
        if (cmd->next)
            count++;
        cmd = cmd->next;
    }
    return (count);
}

void cleanup_pipe_array(int **pipes, int count)
{
    int i;
    if (!pipes || !*pipes)
        return;
    i = 0;
    while (i < count)
    {
        close((*pipes)[i * 2]);
        close((*pipes)[i * 2 + 1]);
        i++;
    }
    free(*pipes);
    *pipes = NULL;
}

int *create_pipes(int count)
{
    int *pipes;
    int i;

    pipes = malloc(sizeof(int) * 2 * count);
    if (!pipes)
        return (NULL);
    i = 0;
    while (i < count)
    {
        if (pipe(pipes + (i * 2)) == -1)
        {
            perror("pipe failed");
            cleanup_pipe_array(&pipes, i);
            return (NULL);
        }
        i++;
    }
    return (pipes);
}

void close_all_pipes(int *pipes, int pipe_count)
{
    int i;

    i = 0;
    while (i < pipe_count * 2)
    {
        close(pipes[i]);
        i++;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 10:33:23 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/31 14:45:17 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

void handle_input_redirection(char *file)
{
    int fd = open(file, O_RDONLY);
    if (fd == -1)
    {
        perror("open failed");
        exit(EXIT_FAILURE);
    }
    if (dup2(fd, STDIN_FILENO) == -1)
    {
        perror("dup2 failed");
        close(fd);
        exit(EXIT_FAILURE);
    }
    close(fd);
}

void handle_output_redirection(char *file)
{
    int fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1)
    {
        perror("open failed");
        exit(EXIT_FAILURE);
    }
    if (dup2(fd, STDOUT_FILENO) == -1)
    {
        perror("dup2 failed");
        close(fd);
        exit(EXIT_FAILURE);
    }
    close(fd);
}

void handle_append_redirection(char *file)
{
    int fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1)
    {
        perror("open failed");
        exit(EXIT_FAILURE);
    }
    if (dup2(fd, STDOUT_FILENO) == -1)
    {
        perror("dup2 failed");
        close(fd);
        exit(EXIT_FAILURE);
    }
    close(fd);
}

static void handle_redirection(t_parsed_cmd *cmd, t_pip *pip)
{
    int i;

    if (!cmd)
        return;

    for (i = 0; i < cmd->input_count; i++)
        handle_input_redirection(cmd->input_file[i]);

    for (i = 0; i < cmd->output_count; i++)
        handle_output_redirection(cmd->output_file[i]);

    for (i = 0; i < cmd->append_count; i++)
        handle_append_redirection(cmd->append_file[i]);

    for (i = 0; i < cmd->heredoc_count; i++)
        handle_heredoc(cmd->heredoc_delim[i], pip);
}

void apply_redirections(t_pip *pip)
{
    if (pip && pip->redirection)
        handle_redirection(pip->redirection, pip);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: cdedessu <cdedessu@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/17 17:42:25 by cdedessu          #+#    #+#             */
/*   Updated: 2025/01/28 13:57:53 by cdedessu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/execution.h"

void	sigint_handler(int sig)
{
	(void)sig;
	write(STDOUT_FILENO, "\nminishell> ", 12);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
}

void	child_sigint_handler(int sig)
{
	(void)sig;
	if (sig == SIGINT)
		write(STDOUT_FILENO, "\n", 1);
}

void	setup_signals(void)
{
	signal(SIGINT, sigint_handler);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGTERM, SIG_IGN);
}

void	setup_child_signals(void)
{
	signal(SIGINT, child_sigint_handler);
	signal(SIGQUIT, SIG_DFL);
}
